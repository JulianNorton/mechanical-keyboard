   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB23:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "action_layer.h"
  26:matrix.c      **** #include "print.h"
  27:matrix.c      **** #include "debug.h"
  28:matrix.c      **** #include "util.h"
  29:matrix.c      **** #include "matrix.h"
  30:matrix.c      **** 
  31:matrix.c      **** 
  32:matrix.c      **** #ifndef DEBOUNCE
  33:matrix.c      **** #   define DEBOUNCE	10
  34:matrix.c      **** #endif
  35:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  36:matrix.c      **** 
  37:matrix.c      **** /* matrix state(1:on, 0:off) */
  38:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  39:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  40:matrix.c      **** 
  41:matrix.c      **** static matrix_row_t read_cols(void);
  42:matrix.c      **** static void init_cols(void);
  43:matrix.c      **** static void unselect_rows(void);
  44:matrix.c      **** static void select_row(uint8_t row);
  45:matrix.c      **** 
  46:matrix.c      **** 
  47:matrix.c      **** inline
  48:matrix.c      **** uint8_t matrix_rows(void)
  49:matrix.c      **** {
  50:matrix.c      ****     return MATRIX_ROWS;
  51:matrix.c      **** }
  52:matrix.c      **** 
  53:matrix.c      **** inline
  54:matrix.c      **** uint8_t matrix_cols(void)
  55:matrix.c      **** {
  56:matrix.c      ****     return MATRIX_COLS;
  57:matrix.c      **** }
  58:matrix.c      **** 
  59:matrix.c      **** void matrix_init(void)
  60:matrix.c      **** {
  61:matrix.c      ****     // initialize row and col
  62:matrix.c      ****     unselect_rows();
  63:matrix.c      ****     init_cols();
  64:matrix.c      **** 
  65:matrix.c      ****     // initialize matrix state: all keys off
  66:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  67:matrix.c      ****         matrix[i] = 0;
  68:matrix.c      ****         matrix_debouncing[i] = 0;
  69:matrix.c      ****     }
  70:matrix.c      **** }
  71:matrix.c      **** 
  72:matrix.c      **** uint8_t matrix_scan(void)
  73:matrix.c      **** {
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  75:matrix.c      ****         select_row(i);
  76:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  77:matrix.c      ****         matrix_row_t cols = read_cols();
  78:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  79:matrix.c      ****             matrix_debouncing[i] = cols;
  80:matrix.c      ****             if (debouncing) {
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  82:matrix.c      ****             }
  83:matrix.c      ****             debouncing = DEBOUNCE;
  84:matrix.c      ****         }
  85:matrix.c      ****         unselect_rows();
  86:matrix.c      ****     }
  87:matrix.c      **** 
  88:matrix.c      ****     if (debouncing) {
  89:matrix.c      ****         if (--debouncing) {
  90:matrix.c      ****             _delay_ms(1);
  91:matrix.c      ****         } else {
  92:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  93:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  94:matrix.c      ****             }
  95:matrix.c      ****         }
  96:matrix.c      ****     }
  97:matrix.c      **** 
  98:matrix.c      ****     uint8_t layer = biton32(layer_state);
  99:matrix.c      ****     switch (layer) {
 100:matrix.c      ****         case 1:
 101:matrix.c      ****         case 2:
 102:matrix.c      ****             DDRC |= (1<<7);
 103:matrix.c      ****             PORTC |= (1<<7);
 104:matrix.c      ****             break;
 105:matrix.c      ****         case 0:
 106:matrix.c      ****             DDRC &= ~(1<<7);
 107:matrix.c      ****             PORTC &= ~(1<<7);
 108:matrix.c      ****             break;
 109:matrix.c      ****     }
 110:matrix.c      **** 
 111:matrix.c      ****     return 1;
 112:matrix.c      **** }
 113:matrix.c      **** 
 114:matrix.c      **** bool matrix_is_modified(void)
 115:matrix.c      **** {
 116:matrix.c      ****     if (debouncing) return false;
 117:matrix.c      ****     return true;
 118:matrix.c      **** }
 119:matrix.c      **** 
 120:matrix.c      **** inline
 121:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 122:matrix.c      **** {
 123:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 124:matrix.c      **** }
 125:matrix.c      **** 
 126:matrix.c      **** inline
 127:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 128:matrix.c      **** {
 129:matrix.c      ****     return matrix[row];
 130:matrix.c      **** }
 131:matrix.c      **** 
 132:matrix.c      **** void matrix_print(void)
 133:matrix.c      **** {
 134:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 135:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 136:matrix.c      ****         phex(row); print(": ");
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 138:matrix.c      ****         print("\n");
 139:matrix.c      ****     }
 140:matrix.c      **** }
 141:matrix.c      **** 
 142:matrix.c      **** uint8_t matrix_key_count(void)
 143:matrix.c      **** {
 144:matrix.c      ****     uint8_t count = 0;
 145:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 146:matrix.c      ****         count += bitpop16(matrix[i]);
 147:matrix.c      ****     }
 148:matrix.c      ****     return count;
 149:matrix.c      **** }
 150:matrix.c      **** 
 151:matrix.c      **** /* Column pin configuration
 152:matrix.c      ****  * col: 0  1  2  3  4  5  6  7  8  9  10 11
 153:matrix.c      ****  * pin: F0 F1 F4 F5 F6 F7 B6 B5 B4 D7 D5 D4
 154:matrix.c      ****  */
 155:matrix.c      **** 
 156:matrix.c      **** static void init_cols(void)
 157:matrix.c      **** {
 158:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 159:matrix.c      ****     // 'F' port columns enabled
 160:matrix.c      ****     DDRF  &= ~(1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 161:matrix.c      ****     PORTF |=  (1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 162:matrix.c      ****     // 'B' port columns enabled
 163:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 164:matrix.c      ****     PORTB |=  (1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 165:matrix.c      ****     // 'D' ports columns enabled
 166:matrix.c      ****     DDRD  &= ~(1<<7);
 167:matrix.c      ****     PORTD |=  (1<<7);
 168:matrix.c      **** }
 169:matrix.c      **** 
 170:matrix.c      **** static matrix_row_t read_cols(void)
 171:matrix.c      **** {
 172:matrix.c      ****     return 
 173:matrix.c      ****            // (PINB&(1<<7) ? 0 : (1<<0))  |
 174:matrix.c      ****            // (PINB&(1<<3) ? 0 : (1<<1))  |
 175:matrix.c      ****            // (PINB&(1<<2) ? 0 : (1<<2))  |
 176:matrix.c      ****            // (PINB&(1<<1) ? 0 : (1<<3))  |
 177:matrix.c      ****            // (PINB&(1<<0) ? 0 : (1<<4))  |
 178:matrix.c      ****            // (PIND&(1<<7) ? 0 : (1<<5))  |
 179:matrix.c      ****            // (PINB&(1<<4) ? 0 : (1<<6))  |
 180:matrix.c      ****            // (PINB&(1<<5) ? 0 : (1<<7))  |
 181:matrix.c      ****            // (PINB&(1<<6) ? 0 : (1<<8))  |
 182:matrix.c      ****            // (PINF&(1<<7) ? 0 : (1<<9))  |
 183:matrix.c      ****            // (PINF&(1<<6) ? 0 : (1<<10)) |
 184:matrix.c      ****            // (PINF&(1<<5) ? 0 : (1<<11)) |
 185:matrix.c      ****            // (PINF&(1<<4) ? 0 : (1<<12)) |
 186:matrix.c      ****            // (PINF&(1<<1) ? 0 : (1<<13)) |
 187:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<<0)) ;
 188:matrix.c      **** }
 189:matrix.c      **** 
 190:matrix.c      **** /* Row pin configuration
 191:matrix.c      ****  * row: 0  1  2  3
 192:matrix.c      ****  * pin: B0 B1 B2 B3
 193:matrix.c      ****  */
 194:matrix.c      **** static void unselect_rows(void)
 195:matrix.c      **** {
  15               		.loc 1 195 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 196:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 197:matrix.c      ****     DDRC  &= ~0b01000000;
  21               		.loc 1 197 0
  22 0000 3E98      		cbi 0x7,6
 198:matrix.c      ****     PORTC &= ~0b01000000;
  23               		.loc 1 198 0
  24 0002 4698      		cbi 0x8,6
 199:matrix.c      ****     DDRD  &= ~0b00001111;
  25               		.loc 1 199 0
  26 0004 8AB1      		in r24,0xa
  27 0006 807F      		andi r24,lo8(-16)
  28 0008 8AB9      		out 0xa,r24
 200:matrix.c      ****     PORTD &= ~0b00001111;
  29               		.loc 1 200 0
  30 000a 8BB1      		in r24,0xb
  31 000c 807F      		andi r24,lo8(-16)
  32 000e 8BB9      		out 0xb,r24
  33 0010 0895      		ret
  34               		.cfi_endproc
  35               	.LFE23:
  37               		.section	.text.matrix_power_up,"ax",@progbits
  38               		.weak	matrix_power_up
  40               	matrix_power_up:
  41               	.LFB9:
  42               		.file 2 "../../common/keyboard.h"
   1:../../common/keyboard.h **** /*
   2:../../common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:../../common/keyboard.h **** 
   4:../../common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:../../common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:../../common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:../../common/keyboard.h **** (at your option) any later version.
   8:../../common/keyboard.h **** 
   9:../../common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:../../common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:../../common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:../../common/keyboard.h **** GNU General Public License for more details.
  13:../../common/keyboard.h **** 
  14:../../common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:../../common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:../../common/keyboard.h **** */
  17:../../common/keyboard.h **** 
  18:../../common/keyboard.h **** #ifndef KEYBOARD_H
  19:../../common/keyboard.h **** #define KEYBOARD_H
  20:../../common/keyboard.h **** 
  21:../../common/keyboard.h **** #include <stdbool.h>
  22:../../common/keyboard.h **** #include <stdint.h>
  23:../../common/keyboard.h **** 
  24:../../common/keyboard.h **** 
  25:../../common/keyboard.h **** #ifdef __cplusplus
  26:../../common/keyboard.h **** extern "C" {
  27:../../common/keyboard.h **** #endif
  28:../../common/keyboard.h **** 
  29:../../common/keyboard.h **** /* key matrix position */
  30:../../common/keyboard.h **** typedef struct {
  31:../../common/keyboard.h ****     uint8_t col;
  32:../../common/keyboard.h ****     uint8_t row;
  33:../../common/keyboard.h **** } keypos_t;
  34:../../common/keyboard.h **** 
  35:../../common/keyboard.h **** /* key event */
  36:../../common/keyboard.h **** typedef struct {
  37:../../common/keyboard.h ****     keypos_t key;
  38:../../common/keyboard.h ****     bool     pressed;
  39:../../common/keyboard.h ****     uint16_t time;
  40:../../common/keyboard.h **** } keyevent_t;
  41:../../common/keyboard.h **** 
  42:../../common/keyboard.h **** /* equivalent test of keypos_t */
  43:../../common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:../../common/keyboard.h **** 
  45:../../common/keyboard.h **** /* Rules for No Event:
  46:../../common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:../../common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:../../common/keyboard.h ****  */
  49:../../common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  50:../../common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
  51:../../common/keyboard.h **** static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
  52:../../common/keyboard.h **** 
  53:../../common/keyboard.h **** /* Tick event */
  54:../../common/keyboard.h **** #define TICK                    (keyevent_t){           \
  55:../../common/keyboard.h ****     .key = (keypos_t){ .row = 255, .col = 255 },           \
  56:../../common/keyboard.h ****     .pressed = false,                                   \
  57:../../common/keyboard.h ****     .time = (timer_read() | 1)                          \
  58:../../common/keyboard.h **** }
  59:../../common/keyboard.h **** 
  60:../../common/keyboard.h **** 
  61:../../common/keyboard.h **** void keyboard_init(void);
  62:../../common/keyboard.h **** void keyboard_task(void);
  63:../../common/keyboard.h **** void keyboard_set_leds(uint8_t leds);
  64:../../common/keyboard.h **** 
  65:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_up(void) {}
  43               		.loc 2 65 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49 0000 0895      		ret
  50               		.cfi_endproc
  51               	.LFE9:
  53               		.section	.text.matrix_power_down,"ax",@progbits
  54               		.weak	matrix_power_down
  56               	matrix_power_down:
  57               	.LFB10:
  66:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_down(void) {}
  58               		.loc 2 66 0
  59               		.cfi_startproc
  60               	/* prologue: function */
  61               	/* frame size = 0 */
  62               	/* stack size = 0 */
  63               	.L__stack_usage = 0
  64 0000 0895      		ret
  65               		.cfi_endproc
  66               	.LFE10:
  68               		.section	.text.matrix_rows,"ax",@progbits
  69               	.global	matrix_rows
  71               	matrix_rows:
  72               	.LFB12:
  49:matrix.c      **** {
  73               		.loc 1 49 0
  74               		.cfi_startproc
  75               	/* prologue: function */
  76               	/* frame size = 0 */
  77               	/* stack size = 0 */
  78               	.L__stack_usage = 0
  51:matrix.c      **** }
  79               		.loc 1 51 0
  80 0000 85E0      		ldi r24,lo8(5)
  81 0002 0895      		ret
  82               		.cfi_endproc
  83               	.LFE12:
  85               		.section	.text.matrix_cols,"ax",@progbits
  86               	.global	matrix_cols
  88               	matrix_cols:
  89               	.LFB13:
  55:matrix.c      **** {
  90               		.loc 1 55 0
  91               		.cfi_startproc
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 0 */
  95               	.L__stack_usage = 0
  57:matrix.c      **** }
  96               		.loc 1 57 0
  97 0000 8EE0      		ldi r24,lo8(14)
  98 0002 0895      		ret
  99               		.cfi_endproc
 100               	.LFE13:
 102               		.section	.text.matrix_init,"ax",@progbits
 103               	.global	matrix_init
 105               	matrix_init:
 106               	.LFB14:
  60:matrix.c      **** {
 107               		.loc 1 60 0
 108               		.cfi_startproc
 109               	/* prologue: function */
 110               	/* frame size = 0 */
 111               	/* stack size = 0 */
 112               	.L__stack_usage = 0
  62:matrix.c      ****     unselect_rows();
 113               		.loc 1 62 0
 114 0000 0E94 0000 		call unselect_rows
 115               	.LVL0:
 116               	.LBB23:
 117               	.LBB24:
 160:matrix.c      ****     DDRF  &= ~(1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 118               		.loc 1 160 0
 119 0004 80B3      		in r24,0x10
 120 0006 8C70      		andi r24,lo8(12)
 121 0008 80BB      		out 0x10,r24
 161:matrix.c      ****     PORTF |=  (1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 122               		.loc 1 161 0
 123 000a 81B3      		in r24,0x11
 124 000c 836F      		ori r24,lo8(-13)
 125 000e 81BB      		out 0x11,r24
 163:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 126               		.loc 1 163 0
 127 0010 84B1      		in r24,0x4
 128 0012 14B8      		out 0x4,__zero_reg__
 164:matrix.c      ****     PORTB |=  (1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 129               		.loc 1 164 0
 130 0014 85B1      		in r24,0x5
 131 0016 8FEF      		ldi r24,lo8(-1)
 132 0018 85B9      		out 0x5,r24
 166:matrix.c      ****     DDRD  &= ~(1<<7);
 133               		.loc 1 166 0
 134 001a 5798      		cbi 0xa,7
 167:matrix.c      ****     PORTD |=  (1<<7);
 135               		.loc 1 167 0
 136 001c 5F9A      		sbi 0xb,7
 137               	.LVL1:
 138 001e E0E0      		ldi r30,lo8(matrix)
 139 0020 F0E0      		ldi r31,hi8(matrix)
 140 0022 A0E0      		ldi r26,lo8(matrix_debouncing)
 141 0024 B0E0      		ldi r27,hi8(matrix_debouncing)
 142               	.LVL2:
 143               	.L8:
 144               	.LBE24:
 145               	.LBE23:
 146               	.LBB25:
  67:matrix.c      ****         matrix[i] = 0;
 147               		.loc 1 67 0 discriminator 2
 148 0026 1192      		st Z+,__zero_reg__
 149 0028 1192      		st Z+,__zero_reg__
  68:matrix.c      ****         matrix_debouncing[i] = 0;
 150               		.loc 1 68 0 discriminator 2
 151 002a 1D92      		st X+,__zero_reg__
 152 002c 1D92      		st X+,__zero_reg__
  66:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 153               		.loc 1 66 0 discriminator 2
 154 002e 80E0      		ldi r24,hi8(matrix+10)
 155 0030 E030      		cpi r30,lo8(matrix+10)
 156 0032 F807      		cpc r31,r24
 157 0034 01F4      		brne .L8
 158               	/* epilogue start */
 159               	.LBE25:
  70:matrix.c      **** }
 160               		.loc 1 70 0
 161 0036 0895      		ret
 162               		.cfi_endproc
 163               	.LFE14:
 165               		.section	.text.matrix_scan,"ax",@progbits
 166               	.global	matrix_scan
 168               	matrix_scan:
 169               	.LFB15:
  73:matrix.c      **** {
 170               		.loc 1 73 0
 171               		.cfi_startproc
 172 0000 DF92      		push r13
 173               	.LCFI0:
 174               		.cfi_def_cfa_offset 3
 175               		.cfi_offset 13, -2
 176 0002 EF92      		push r14
 177               	.LCFI1:
 178               		.cfi_def_cfa_offset 4
 179               		.cfi_offset 14, -3
 180 0004 FF92      		push r15
 181               	.LCFI2:
 182               		.cfi_def_cfa_offset 5
 183               		.cfi_offset 15, -4
 184 0006 0F93      		push r16
 185               	.LCFI3:
 186               		.cfi_def_cfa_offset 6
 187               		.cfi_offset 16, -5
 188 0008 1F93      		push r17
 189               	.LCFI4:
 190               		.cfi_def_cfa_offset 7
 191               		.cfi_offset 17, -6
 192 000a CF93      		push r28
 193               	.LCFI5:
 194               		.cfi_def_cfa_offset 8
 195               		.cfi_offset 28, -7
 196 000c DF93      		push r29
 197               	.LCFI6:
 198               		.cfi_def_cfa_offset 9
 199               		.cfi_offset 29, -8
 200               	/* prologue: function */
 201               	/* frame size = 0 */
 202               	/* stack size = 7 */
 203               	.L__stack_usage = 7
 204               	.LVL3:
  73:matrix.c      **** {
 205               		.loc 1 73 0
 206 000e C0E0      		ldi r28,lo8(matrix_debouncing)
 207 0010 D0E0      		ldi r29,hi8(matrix_debouncing)
 208               	.LBB40:
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 209               		.loc 1 74 0
 210 0012 10E0      		ldi r17,0
 211 0014 01E0      		ldi r16,lo8(1)
 212               	.LBB41:
  83:matrix.c      ****             debouncing = DEBOUNCE;
 213               		.loc 1 83 0
 214 0016 85E0      		ldi r24,lo8(5)
 215 0018 D82E      		mov r13,r24
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 216               		.loc 1 81 0
 217 001a 90E0      		ldi r25,lo8(__c.2329)
 218 001c E92E      		mov r14,r25
 219 001e 90E0      		ldi r25,hi8(__c.2329)
 220 0020 F92E      		mov r15,r25
 221               	.LVL4:
 222               	.L25:
 223               	.LBB42:
 224               	.LBB43:
 201:matrix.c      **** }
 202:matrix.c      **** 
 203:matrix.c      **** static void select_row(uint8_t row)
 204:matrix.c      **** {
 205:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 206:matrix.c      ****        switch (row) {
 225               		.loc 1 206 0
 226 0022 1230      		cpi r17,lo8(2)
 227 0024 01F0      		breq .L12
 228 0026 00F4      		brsh .L13
 229 0028 1130      		cpi r17,lo8(1)
 230 002a 01F0      		breq .L14
 231 002c 00C0      		rjmp .L11
 232               	.L13:
 233 002e 1330      		cpi r17,lo8(3)
 234 0030 01F0      		breq .L15
 235 0032 1430      		cpi r17,lo8(4)
 236 0034 01F0      		breq .L16
 237               	.L11:
 207:matrix.c      ****            case 0:
 208:matrix.c      ****                DDRD  |= (1<<0);
 238               		.loc 1 208 0
 239 0036 509A      		sbi 0xa,0
 209:matrix.c      ****                PORTD &= ~(1<<0);
 240               		.loc 1 209 0
 241 0038 5898      		cbi 0xb,0
 242 003a 00C0      		rjmp .L17
 243               	.L14:
 210:matrix.c      ****                break;
 211:matrix.c      ****            case 1:
 212:matrix.c      ****                DDRD  |= (1<<1);
 244               		.loc 1 212 0
 245 003c 519A      		sbi 0xa,1
 213:matrix.c      ****                PORTD &= ~(1<<1);
 246               		.loc 1 213 0
 247 003e 5998      		cbi 0xb,1
 248 0040 00C0      		rjmp .L17
 249               	.L12:
 214:matrix.c      ****                break;
 215:matrix.c      ****            case 2:
 216:matrix.c      ****                DDRD  |= (1<<2);
 250               		.loc 1 216 0
 251 0042 529A      		sbi 0xa,2
 217:matrix.c      ****                PORTD &= ~(1<<2);
 252               		.loc 1 217 0
 253 0044 5A98      		cbi 0xb,2
 254 0046 00C0      		rjmp .L17
 255               	.L15:
 218:matrix.c      ****                break;
 219:matrix.c      ****            case 3:
 220:matrix.c      ****                DDRD  |= (1<<3);
 256               		.loc 1 220 0
 257 0048 539A      		sbi 0xa,3
 221:matrix.c      ****                PORTD &= ~(1<<3);
 258               		.loc 1 221 0
 259 004a 5B98      		cbi 0xb,3
 260 004c 00C0      		rjmp .L17
 261               	.L16:
 222:matrix.c      ****                break;
 223:matrix.c      ****            case 4:
 224:matrix.c      ****                DDRC  |= (1<<6);
 262               		.loc 1 224 0
 263 004e 3E9A      		sbi 0x7,6
 225:matrix.c      ****                PORTC &= ~(1<<6);
 264               		.loc 1 225 0
 265 0050 4698      		cbi 0x8,6
 266               	.L17:
 267               	.LVL5:
 268               	.LBE43:
 269               	.LBE42:
 270               	.LBB44:
 271               	.LBB45:
 272               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 273               		.loc 3 245 0
 274 0052 80EA      		ldi r24,lo8(-96)
 275 0054 8A95      		1: dec r24
 276 0056 01F4      		brne 1b
 277               	.LBE45:
 278               	.LBE44:
 279               	.LBB46:
 280               	.LBB47:
 187:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<<0)) ;
 281               		.loc 1 187 0
 282 0058 8FB1      		in r24,0xf
 283 005a 8170      		andi r24,lo8(1)
 284 005c 8027      		eor r24,r16
 172:matrix.c      ****     return 
 285               		.loc 1 172 0
 286 005e 90E0      		ldi r25,0
 287               	.LBE47:
 288               	.LBE46:
  78:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 289               		.loc 1 78 0
 290 0060 2881      		ld r18,Y
 291 0062 3981      		ldd r19,Y+1
 292 0064 2817      		cp r18,r24
 293 0066 3907      		cpc r19,r25
 294 0068 01F0      		breq .L18
  79:matrix.c      ****             matrix_debouncing[i] = cols;
 295               		.loc 1 79 0
 296 006a 9983      		std Y+1,r25
 297 006c 8883      		st Y,r24
  80:matrix.c      ****             if (debouncing) {
 298               		.loc 1 80 0
 299 006e 8091 0000 		lds r24,debouncing
 300 0072 8823      		tst r24
 301 0074 01F0      		breq .L20
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 302               		.loc 1 81 0
 303 0076 8091 0000 		lds r24,debug_config
 304 007a 80FF      		sbrs r24,0
 305 007c 00C0      		rjmp .L21
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 306               		.loc 1 81 0 is_stmt 0 discriminator 1
 307 007e 80E0      		ldi r24,lo8(__c.2327)
 308 0080 90E0      		ldi r25,hi8(__c.2327)
 309 0082 0E94 0000 		call xputs
 310               	.LVL6:
 311               	.L21:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 312               		.loc 1 81 0 discriminator 2
 313 0086 8091 0000 		lds r24,debug_config
 314 008a 80FF      		sbrs r24,0
 315 008c 00C0      		rjmp .L22
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 316               		.loc 1 81 0 discriminator 1
 317 008e 8091 0000 		lds r24,debouncing
 318 0092 1F92      		push __zero_reg__
 319               	.LCFI7:
 320               		.cfi_def_cfa_offset 10
 321 0094 8F93      		push r24
 322               	.LCFI8:
 323               		.cfi_def_cfa_offset 11
 324 0096 FF92      		push r15
 325               	.LCFI9:
 326               		.cfi_def_cfa_offset 12
 327 0098 EF92      		push r14
 328               	.LCFI10:
 329               		.cfi_def_cfa_offset 13
 330 009a 0E94 0000 		call __xprintf
 331               	.LVL7:
 332 009e 0F90      		pop __tmp_reg__
 333 00a0 0F90      		pop __tmp_reg__
 334 00a2 0F90      		pop __tmp_reg__
 335 00a4 0F90      		pop __tmp_reg__
 336               	.LCFI11:
 337               		.cfi_def_cfa_offset 9
 338               	.L22:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 339               		.loc 1 81 0 discriminator 2
 340 00a6 8091 0000 		lds r24,debug_config
 341 00aa 80FF      		sbrs r24,0
 342 00ac 00C0      		rjmp .L20
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 343               		.loc 1 81 0 discriminator 1
 344 00ae 80E0      		ldi r24,lo8(__c.2331)
 345 00b0 90E0      		ldi r25,hi8(__c.2331)
 346 00b2 0E94 0000 		call xputs
 347               	.LVL8:
 348               	.L20:
  83:matrix.c      ****             debouncing = DEBOUNCE;
 349               		.loc 1 83 0 is_stmt 1
 350 00b6 D092 0000 		sts debouncing,r13
 351               	.L18:
  85:matrix.c      ****         unselect_rows();
 352               		.loc 1 85 0
 353 00ba 0E94 0000 		call unselect_rows
 354               	.LVL9:
 355               	.LBE41:
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 356               		.loc 1 74 0
 357 00be 1F5F      		subi r17,lo8(-(1))
 358               	.LVL10:
 359 00c0 2296      		adiw r28,2
 360 00c2 1530      		cpi r17,lo8(5)
 361 00c4 01F0      		breq .+2
 362 00c6 00C0      		rjmp .L25
 363               	.LBE40:
  88:matrix.c      ****     if (debouncing) {
 364               		.loc 1 88 0
 365 00c8 8091 0000 		lds r24,debouncing
 366 00cc 8823      		tst r24
 367 00ce 01F0      		breq .L27
  89:matrix.c      ****         if (--debouncing) {
 368               		.loc 1 89 0
 369 00d0 8150      		subi r24,lo8(-(-1))
 370 00d2 8093 0000 		sts debouncing,r24
 371 00d6 8823      		tst r24
 372 00d8 01F0      		breq .L28
 373               	.LVL11:
 374               	.LBB48:
 375               	.LBB49:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 376               		.loc 3 163 0
 377 00da 8FE9      		ldi r24,lo8(3999)
 378 00dc 9FE0      		ldi r25,hi8(3999)
 379 00de 0197      		1: sbiw r24,1
 380 00e0 01F4      		brne 1b
 381 00e2 00C0      		rjmp .
 382 00e4 0000      		nop
 383 00e6 00C0      		rjmp .L27
 384               	.LVL12:
 385               	.L28:
 386 00e8 A0E0      		ldi r26,lo8(matrix)
 387 00ea B0E0      		ldi r27,hi8(matrix)
 388               	.LBE49:
 389               	.LBE48:
  89:matrix.c      ****         if (--debouncing) {
 390               		.loc 1 89 0
 391 00ec E0E0      		ldi r30,lo8(matrix_debouncing)
 392 00ee F0E0      		ldi r31,hi8(matrix_debouncing)
 393               	.L30:
 394               	.LBB50:
  93:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 395               		.loc 1 93 0 discriminator 2
 396 00f0 8191      		ld r24,Z+
 397 00f2 9191      		ld r25,Z+
 398 00f4 8D93      		st X+,r24
 399 00f6 9D93      		st X+,r25
 400               	.LVL13:
  92:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 401               		.loc 1 92 0 discriminator 2
 402 00f8 90E0      		ldi r25,hi8(matrix_debouncing+10)
 403 00fa E030      		cpi r30,lo8(matrix_debouncing+10)
 404 00fc F907      		cpc r31,r25
 405 00fe 01F4      		brne .L30
 406               	.L27:
 407               	.LBE50:
  98:matrix.c      ****     uint8_t layer = biton32(layer_state);
 408               		.loc 1 98 0
 409 0100 6091 0000 		lds r22,layer_state
 410 0104 7091 0000 		lds r23,layer_state+1
 411 0108 8091 0000 		lds r24,layer_state+2
 412 010c 9091 0000 		lds r25,layer_state+3
 413 0110 0E94 0000 		call biton32
 414               	.LVL14:
  99:matrix.c      ****     switch (layer) {
 415               		.loc 1 99 0
 416 0114 8823      		tst r24
 417 0116 01F0      		breq .L32
 418 0118 8330      		cpi r24,lo8(3)
 419 011a 00F4      		brsh .L31
 102:matrix.c      ****             DDRC |= (1<<7);
 420               		.loc 1 102 0
 421 011c 3F9A      		sbi 0x7,7
 103:matrix.c      ****             PORTC |= (1<<7);
 422               		.loc 1 103 0
 423 011e 479A      		sbi 0x8,7
 104:matrix.c      ****             break;
 424               		.loc 1 104 0
 425 0120 00C0      		rjmp .L31
 426               	.L32:
 106:matrix.c      ****             DDRC &= ~(1<<7);
 427               		.loc 1 106 0
 428 0122 3F98      		cbi 0x7,7
 107:matrix.c      ****             PORTC &= ~(1<<7);
 429               		.loc 1 107 0
 430 0124 4798      		cbi 0x8,7
 431               	.L31:
 112:matrix.c      **** }
 432               		.loc 1 112 0
 433 0126 81E0      		ldi r24,lo8(1)
 434               	.LVL15:
 435               	/* epilogue start */
 436 0128 DF91      		pop r29
 437 012a CF91      		pop r28
 438 012c 1F91      		pop r17
 439               	.LVL16:
 440 012e 0F91      		pop r16
 441 0130 FF90      		pop r15
 442 0132 EF90      		pop r14
 443 0134 DF90      		pop r13
 444 0136 0895      		ret
 445               		.cfi_endproc
 446               	.LFE15:
 448               		.section	.text.matrix_is_modified,"ax",@progbits
 449               	.global	matrix_is_modified
 451               	matrix_is_modified:
 452               	.LFB16:
 115:matrix.c      **** {
 453               		.loc 1 115 0
 454               		.cfi_startproc
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 0 */
 458               	.L__stack_usage = 0
 116:matrix.c      ****     if (debouncing) return false;
 459               		.loc 1 116 0
 460 0000 81E0      		ldi r24,lo8(1)
 461 0002 9091 0000 		lds r25,debouncing
 462 0006 9111      		cpse r25,__zero_reg__
 463 0008 80E0      		ldi r24,0
 464               	.L46:
 118:matrix.c      **** }
 465               		.loc 1 118 0
 466 000a 0895      		ret
 467               		.cfi_endproc
 468               	.LFE16:
 470               		.section	.text.matrix_is_on,"ax",@progbits
 471               	.global	matrix_is_on
 473               	matrix_is_on:
 474               	.LFB17:
 122:matrix.c      **** {
 475               		.loc 1 122 0
 476               		.cfi_startproc
 477               	.LVL17:
 478               	/* prologue: function */
 479               	/* frame size = 0 */
 480               	/* stack size = 0 */
 481               	.L__stack_usage = 0
 123:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 482               		.loc 1 123 0
 483 0000 E82F      		mov r30,r24
 484 0002 F0E0      		ldi r31,0
 485 0004 EE0F      		lsl r30
 486 0006 FF1F      		rol r31
 487 0008 E050      		subi r30,lo8(-(matrix))
 488 000a F040      		sbci r31,hi8(-(matrix))
 489 000c 21E0      		ldi r18,lo8(1)
 490 000e 30E0      		ldi r19,0
 491 0010 00C0      		rjmp 2f
 492               		1:
 493 0012 220F      		lsl r18
 494 0014 331F      		rol r19
 495               		2:
 496 0016 6A95      		dec r22
 497 0018 02F4      		brpl 1b
 498 001a 8081      		ld r24,Z
 499 001c 9181      		ldd r25,Z+1
 500               	.LVL18:
 501 001e 2823      		and r18,r24
 502 0020 3923      		and r19,r25
 503 0022 81E0      		ldi r24,lo8(1)
 504 0024 232B      		or r18,r19
 505 0026 01F4      		brne .L51
 506 0028 80E0      		ldi r24,0
 507               	.L51:
 124:matrix.c      **** }
 508               		.loc 1 124 0
 509 002a 0895      		ret
 510               		.cfi_endproc
 511               	.LFE17:
 513               		.section	.text.matrix_get_row,"ax",@progbits
 514               	.global	matrix_get_row
 516               	matrix_get_row:
 517               	.LFB18:
 128:matrix.c      **** {
 518               		.loc 1 128 0
 519               		.cfi_startproc
 520               	.LVL19:
 521               	/* prologue: function */
 522               	/* frame size = 0 */
 523               	/* stack size = 0 */
 524               	.L__stack_usage = 0
 129:matrix.c      ****     return matrix[row];
 525               		.loc 1 129 0
 526 0000 E82F      		mov r30,r24
 527 0002 F0E0      		ldi r31,0
 528 0004 EE0F      		lsl r30
 529 0006 FF1F      		rol r31
 530 0008 E050      		subi r30,lo8(-(matrix))
 531 000a F040      		sbci r31,hi8(-(matrix))
 130:matrix.c      **** }
 532               		.loc 1 130 0
 533 000c 8081      		ld r24,Z
 534 000e 9181      		ldd r25,Z+1
 535               	.LVL20:
 536 0010 0895      		ret
 537               		.cfi_endproc
 538               	.LFE18:
 540               		.section	.text.matrix_print,"ax",@progbits
 541               	.global	matrix_print
 543               	matrix_print:
 544               	.LFB19:
 133:matrix.c      **** {
 545               		.loc 1 133 0
 546               		.cfi_startproc
 547 0000 CF92      		push r12
 548               	.LCFI12:
 549               		.cfi_def_cfa_offset 3
 550               		.cfi_offset 12, -2
 551 0002 DF92      		push r13
 552               	.LCFI13:
 553               		.cfi_def_cfa_offset 4
 554               		.cfi_offset 13, -3
 555 0004 EF92      		push r14
 556               	.LCFI14:
 557               		.cfi_def_cfa_offset 5
 558               		.cfi_offset 14, -4
 559 0006 FF92      		push r15
 560               	.LCFI15:
 561               		.cfi_def_cfa_offset 6
 562               		.cfi_offset 15, -5
 563 0008 0F93      		push r16
 564               	.LCFI16:
 565               		.cfi_def_cfa_offset 7
 566               		.cfi_offset 16, -6
 567 000a 1F93      		push r17
 568               	.LCFI17:
 569               		.cfi_def_cfa_offset 8
 570               		.cfi_offset 17, -7
 571 000c CF93      		push r28
 572               	.LCFI18:
 573               		.cfi_def_cfa_offset 9
 574               		.cfi_offset 28, -8
 575 000e DF93      		push r29
 576               	.LCFI19:
 577               		.cfi_def_cfa_offset 10
 578               		.cfi_offset 29, -9
 579               	/* prologue: function */
 580               	/* frame size = 0 */
 581               	/* stack size = 8 */
 582               	.L__stack_usage = 8
 134:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 583               		.loc 1 134 0
 584 0010 80E0      		ldi r24,lo8(__c.2358)
 585 0012 90E0      		ldi r25,hi8(__c.2358)
 586 0014 0E94 0000 		call xputs
 587 0018 40E0      		ldi r20,lo8(matrix)
 588 001a E42E      		mov r14,r20
 589 001c 40E0      		ldi r20,hi8(matrix)
 590 001e F42E      		mov r15,r20
 591 0020 C0E0      		ldi r28,0
 592 0022 D0E0      		ldi r29,0
 593               	.LBB51:
 136:matrix.c      ****         phex(row); print(": ");
 594               		.loc 1 136 0
 595 0024 50E0      		ldi r21,lo8(__c.2361)
 596 0026 C52E      		mov r12,r21
 597 0028 50E0      		ldi r21,hi8(__c.2361)
 598 002a D52E      		mov r13,r21
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 599               		.loc 1 137 0
 600 002c 00E0      		ldi r16,lo8(__c.2365)
 601 002e 10E0      		ldi r17,hi8(__c.2365)
 602               	.L55:
 136:matrix.c      ****         phex(row); print(": ");
 603               		.loc 1 136 0 discriminator 2
 604 0030 DF93      		push r29
 605               	.LCFI20:
 606               		.cfi_def_cfa_offset 11
 607 0032 CF93      		push r28
 608               	.LCFI21:
 609               		.cfi_def_cfa_offset 12
 610 0034 DF92      		push r13
 611               	.LCFI22:
 612               		.cfi_def_cfa_offset 13
 613 0036 CF92      		push r12
 614               	.LCFI23:
 615               		.cfi_def_cfa_offset 14
 616 0038 0E94 0000 		call __xprintf
 617 003c 80E0      		ldi r24,lo8(__c.2363)
 618 003e 90E0      		ldi r25,hi8(__c.2363)
 619 0040 0E94 0000 		call xputs
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 620               		.loc 1 137 0 discriminator 2
 621 0044 F701      		movw r30,r14
 622 0046 8191      		ld r24,Z+
 623 0048 9191      		ld r25,Z+
 624 004a 7F01      		movw r14,r30
 625 004c 0E94 0000 		call bitrev16
 626 0050 9F93      		push r25
 627               	.LCFI24:
 628               		.cfi_def_cfa_offset 15
 629 0052 8F93      		push r24
 630               	.LCFI25:
 631               		.cfi_def_cfa_offset 16
 632 0054 1F93      		push r17
 633               	.LCFI26:
 634               		.cfi_def_cfa_offset 17
 635 0056 0F93      		push r16
 636               	.LCFI27:
 637               		.cfi_def_cfa_offset 18
 638 0058 0E94 0000 		call __xprintf
 138:matrix.c      ****         print("\n");
 639               		.loc 1 138 0 discriminator 2
 640 005c 80E0      		ldi r24,lo8(__c.2367)
 641 005e 90E0      		ldi r25,hi8(__c.2367)
 642 0060 0E94 0000 		call xputs
 643 0064 2196      		adiw r28,1
 135:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 644               		.loc 1 135 0 discriminator 2
 645 0066 8DB7      		in r24,__SP_L__
 646 0068 9EB7      		in r25,__SP_H__
 647 006a 0896      		adiw r24,8
 648 006c 0FB6      		in __tmp_reg__,__SREG__
 649 006e F894      		cli
 650 0070 9EBF      		out __SP_H__,r25
 651 0072 0FBE      		out __SREG__,__tmp_reg__
 652 0074 8DBF      		out __SP_L__,r24
 653               	.LCFI28:
 654               		.cfi_def_cfa_offset 10
 655 0076 C530      		cpi r28,5
 656 0078 D105      		cpc r29,__zero_reg__
 657 007a 01F4      		brne .L55
 658               	/* epilogue start */
 659               	.LBE51:
 140:matrix.c      **** }
 660               		.loc 1 140 0
 661 007c DF91      		pop r29
 662 007e CF91      		pop r28
 663 0080 1F91      		pop r17
 664 0082 0F91      		pop r16
 665 0084 FF90      		pop r15
 666 0086 EF90      		pop r14
 667 0088 DF90      		pop r13
 668 008a CF90      		pop r12
 669 008c 0895      		ret
 670               		.cfi_endproc
 671               	.LFE19:
 673               		.section	.text.matrix_key_count,"ax",@progbits
 674               	.global	matrix_key_count
 676               	matrix_key_count:
 677               	.LFB20:
 143:matrix.c      **** {
 678               		.loc 1 143 0
 679               		.cfi_startproc
 680 0000 1F93      		push r17
 681               	.LCFI29:
 682               		.cfi_def_cfa_offset 3
 683               		.cfi_offset 17, -2
 684 0002 CF93      		push r28
 685               	.LCFI30:
 686               		.cfi_def_cfa_offset 4
 687               		.cfi_offset 28, -3
 688 0004 DF93      		push r29
 689               	.LCFI31:
 690               		.cfi_def_cfa_offset 5
 691               		.cfi_offset 29, -4
 692               	/* prologue: function */
 693               	/* frame size = 0 */
 694               	/* stack size = 3 */
 695               	.L__stack_usage = 3
 696               	.LVL21:
 697 0006 C0E0      		ldi r28,lo8(matrix)
 698 0008 D0E0      		ldi r29,hi8(matrix)
 144:matrix.c      ****     uint8_t count = 0;
 699               		.loc 1 144 0
 700 000a 10E0      		ldi r17,0
 701               	.LVL22:
 702               	.L58:
 703               	.LBB52:
 146:matrix.c      ****         count += bitpop16(matrix[i]);
 704               		.loc 1 146 0 discriminator 2
 705 000c 8991      		ld r24,Y+
 706 000e 9991      		ld r25,Y+
 707 0010 0E94 0000 		call bitpop16
 708               	.LVL23:
 709 0014 180F      		add r17,r24
 710               	.LVL24:
 145:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 711               		.loc 1 145 0 discriminator 2
 712 0016 80E0      		ldi r24,hi8(matrix+10)
 713 0018 C030      		cpi r28,lo8(matrix+10)
 714 001a D807      		cpc r29,r24
 715 001c 01F4      		brne .L58
 716               	.LBE52:
 149:matrix.c      **** }
 717               		.loc 1 149 0
 718 001e 812F      		mov r24,r17
 719               	/* epilogue start */
 720 0020 DF91      		pop r29
 721 0022 CF91      		pop r28
 722 0024 1F91      		pop r17
 723               	.LVL25:
 724 0026 0895      		ret
 725               		.cfi_endproc
 726               	.LFE20:
 728               		.section	.progmem.data,"a",@progbits
 731               	__c.2367:
 732 0000 0A00      		.string	"\n"
 735               	__c.2365:
 736 0002 2530 3136 		.string	"%016b"
 736      6200 
 739               	__c.2363:
 740 0008 3A20 00   		.string	": "
 743               	__c.2361:
 744 000b 2530 3258 		.string	"%02X"
 744      00
 747               	__c.2358:
 748 0010 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 748      2030 3132 
 748      3334 3536 
 748      3738 3941 
 748      4243 4445 
 751               	__c.2331:
 752 0027 0A00      		.string	"\n"
 755               	__c.2329:
 756 0029 2530 3258 		.string	"%02X"
 756      00
 759               	__c.2327:
 760 002e 626F 756E 		.string	"bounce!: "
 760      6365 213A 
 760      2000 
 761               		.local	matrix_debouncing
 762               		.comm	matrix_debouncing,10,1
 763               		.local	matrix
 764               		.comm	matrix,10,1
 765               		.data
 768               	debouncing:
 769 0000 05        		.byte	5
 770               		.text
 771               	.Letext0:
 772               		.file 4 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 773               		.file 5 "../../common/debug.h"
 774               		.file 6 "../../common/matrix.h"
 775               		.file 7 "../../common/action_layer.h"
 776               		.file 8 "../../common/avr/xprintf.h"
 777               		.file 9 "../../common/util.h"
DEFINED SYMBOLS
                            *ABS*:00000000 matrix.c
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:2      *ABS*:0000003e __SP_H__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:3      *ABS*:0000003d __SP_L__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:4      *ABS*:0000003f __SREG__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:6      *ABS*:00000001 __zero_reg__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:12     .text.unselect_rows:00000000 unselect_rows
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:40     .text.matrix_power_up:00000000 matrix_power_up
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:56     .text.matrix_power_down:00000000 matrix_power_down
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:71     .text.matrix_rows:00000000 matrix_rows
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:88     .text.matrix_cols:00000000 matrix_cols
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:105    .text.matrix_init:00000000 matrix_init
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:762    .bss:0000000a matrix
                             .bss:00000000 matrix_debouncing
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:168    .text.matrix_scan:00000000 matrix_scan
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:755    .progmem.data:00000029 __c.2329
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:768    .data:00000000 debouncing
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:759    .progmem.data:0000002e __c.2327
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:751    .progmem.data:00000027 __c.2331
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:451    .text.matrix_is_modified:00000000 matrix_is_modified
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:473    .text.matrix_is_on:00000000 matrix_is_on
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:516    .text.matrix_get_row:00000000 matrix_get_row
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:543    .text.matrix_print:00000000 matrix_print
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:747    .progmem.data:00000010 __c.2358
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:743    .progmem.data:0000000b __c.2361
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:735    .progmem.data:00000002 __c.2365
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:739    .progmem.data:00000008 __c.2363
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:731    .progmem.data:00000000 __c.2367
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccbLeklM.s:676    .text.matrix_key_count:00000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
layer_state
biton32
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
