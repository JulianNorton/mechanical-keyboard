   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB23:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "action_layer.h"
  26:matrix.c      **** #include "print.h"
  27:matrix.c      **** #include "debug.h"
  28:matrix.c      **** #include "util.h"
  29:matrix.c      **** #include "matrix.h"
  30:matrix.c      **** 
  31:matrix.c      **** 
  32:matrix.c      **** #ifndef DEBOUNCE
  33:matrix.c      **** #   define DEBOUNCE	10
  34:matrix.c      **** #endif
  35:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  36:matrix.c      **** 
  37:matrix.c      **** /* matrix state(1:on, 0:off) */
  38:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  39:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  40:matrix.c      **** 
  41:matrix.c      **** static matrix_row_t read_cols(void);
  42:matrix.c      **** static void init_cols(void);
  43:matrix.c      **** static void unselect_rows(void);
  44:matrix.c      **** static void select_row(uint8_t row);
  45:matrix.c      **** 
  46:matrix.c      **** 
  47:matrix.c      **** inline
  48:matrix.c      **** uint8_t matrix_rows(void)
  49:matrix.c      **** {
  50:matrix.c      ****     return MATRIX_ROWS;
  51:matrix.c      **** }
  52:matrix.c      **** 
  53:matrix.c      **** inline
  54:matrix.c      **** uint8_t matrix_cols(void)
  55:matrix.c      **** {
  56:matrix.c      ****     return MATRIX_COLS;
  57:matrix.c      **** }
  58:matrix.c      **** 
  59:matrix.c      **** void matrix_init(void)
  60:matrix.c      **** {
  61:matrix.c      ****     // initialize row and col
  62:matrix.c      ****     unselect_rows();
  63:matrix.c      ****     init_cols();
  64:matrix.c      **** 
  65:matrix.c      ****     // initialize matrix state: all keys off
  66:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  67:matrix.c      ****         matrix[i] = 0;
  68:matrix.c      ****         matrix_debouncing[i] = 0;
  69:matrix.c      ****     }
  70:matrix.c      **** }
  71:matrix.c      **** 
  72:matrix.c      **** uint8_t matrix_scan(void)
  73:matrix.c      **** {
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  75:matrix.c      ****         select_row(i);
  76:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  77:matrix.c      ****         matrix_row_t cols = read_cols();
  78:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  79:matrix.c      ****             matrix_debouncing[i] = cols;
  80:matrix.c      ****             if (debouncing) {
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  82:matrix.c      ****             }
  83:matrix.c      ****             debouncing = DEBOUNCE;
  84:matrix.c      ****         }
  85:matrix.c      ****         unselect_rows();
  86:matrix.c      ****     }
  87:matrix.c      **** 
  88:matrix.c      ****     if (debouncing) {
  89:matrix.c      ****         if (--debouncing) {
  90:matrix.c      ****             _delay_ms(1);
  91:matrix.c      ****         } else {
  92:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  93:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  94:matrix.c      ****             }
  95:matrix.c      ****         }
  96:matrix.c      ****     }
  97:matrix.c      **** 
  98:matrix.c      ****     uint8_t layer = biton32(layer_state);
  99:matrix.c      ****     switch (layer) {
 100:matrix.c      ****         case 1:
 101:matrix.c      ****         case 2:
 102:matrix.c      ****             DDRC |= (1<<7);
 103:matrix.c      ****             PORTC |= (1<<7);
 104:matrix.c      ****             break;
 105:matrix.c      ****         case 0:
 106:matrix.c      ****             DDRC &= ~(1<<7);
 107:matrix.c      ****             PORTC &= ~(1<<7);
 108:matrix.c      ****             break;
 109:matrix.c      ****     }
 110:matrix.c      **** 
 111:matrix.c      ****     return 1;
 112:matrix.c      **** }
 113:matrix.c      **** 
 114:matrix.c      **** bool matrix_is_modified(void)
 115:matrix.c      **** {
 116:matrix.c      ****     if (debouncing) return false;
 117:matrix.c      ****     return true;
 118:matrix.c      **** }
 119:matrix.c      **** 
 120:matrix.c      **** inline
 121:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 122:matrix.c      **** {
 123:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 124:matrix.c      **** }
 125:matrix.c      **** 
 126:matrix.c      **** inline
 127:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 128:matrix.c      **** {
 129:matrix.c      ****     return matrix[row];
 130:matrix.c      **** }
 131:matrix.c      **** 
 132:matrix.c      **** void matrix_print(void)
 133:matrix.c      **** {
 134:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 135:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 136:matrix.c      ****         phex(row); print(": ");
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 138:matrix.c      ****         print("\n");
 139:matrix.c      ****     }
 140:matrix.c      **** }
 141:matrix.c      **** 
 142:matrix.c      **** uint8_t matrix_key_count(void)
 143:matrix.c      **** {
 144:matrix.c      ****     uint8_t count = 0;
 145:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 146:matrix.c      ****         count += bitpop16(matrix[i]);
 147:matrix.c      ****     }
 148:matrix.c      ****     return count;
 149:matrix.c      **** }
 150:matrix.c      **** 
 151:matrix.c      **** /* Column pin configuration
 152:matrix.c      ****  * col: 0  1  2  3  4  5  6  7  8  9  10 11
 153:matrix.c      ****  * pin: F0 F1 F4 F5 F6 F7 B6 B5 B4 D7 D5 D4
 154:matrix.c      ****  */
 155:matrix.c      **** 
 156:matrix.c      **** static void init_cols(void)
 157:matrix.c      **** {
 158:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 159:matrix.c      ****     // 'F' port columns enabled
 160:matrix.c      ****     DDRF  &= ~(1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 161:matrix.c      ****     PORTF |=  (1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 162:matrix.c      ****     // 'B' port columns enabled
 163:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 164:matrix.c      ****     PORTB |=  (1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 165:matrix.c      ****     // 'D' ports columns enabled
 166:matrix.c      ****     DDRD  &= ~(1<<7);
 167:matrix.c      ****     PORTD |=  (1<<7);
 168:matrix.c      **** }
 169:matrix.c      **** 
 170:matrix.c      **** static matrix_row_t read_cols(void)
 171:matrix.c      **** {
 172:matrix.c      ****     return 
 173:matrix.c      ****            // (PINB&(1<<7) ? 0 : (1<<0)) |
 174:matrix.c      ****            // (PINB&(1<<3) ? 0 : (1<<1)) |
 175:matrix.c      ****            // (PINB&(1<<2) ? 0 : (1<<2)) |
 176:matrix.c      ****            // (PINB&(1<<1) ? 0 : (1<<3)) |
 177:matrix.c      ****            // (PINB&(1<<0) ? 0 : (1<<4)) |
 178:matrix.c      ****            // (PIND&(1<<7) ? 0 : (1<<5)) |
 179:matrix.c      ****            // (PINB&(1<<4) ? 0 : (1<<6)) |
 180:matrix.c      ****            // (PINB&(1<<5) ? 0 : (1<<7)) |
 181:matrix.c      ****            // (PINB&(1<<6) ? 0 : (1<<8)) |
 182:matrix.c      ****            // (PINF&(1<<7) ? 0 : (1<<9)) |
 183:matrix.c      ****            // (PINF&(1<<6) ? 0 : (1<<10)) |
 184:matrix.c      ****            // (PINF&(1<<5) ? 0 : (1<<11)) |
 185:matrix.c      ****            // (PINF&(1<<4) ? 0 : (1<<12)) |
 186:matrix.c      ****            // (PINF&(1<<1) ? 0 : (1<<13)) |
 187:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<<0)) ;
 188:matrix.c      **** }
 189:matrix.c      **** 
 190:matrix.c      **** /* Row pin configuration
 191:matrix.c      ****  * row: 0  1  2  3
 192:matrix.c      ****  * pin: B0 B1 B2 B3
 193:matrix.c      ****  */
 194:matrix.c      **** static void unselect_rows(void)
 195:matrix.c      **** {
  15               		.loc 1 195 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 196:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 197:matrix.c      ****     DDRC  &= ~0b01000000;
  21               		.loc 1 197 0
  22 0000 3E98      		cbi 0x7,6
 198:matrix.c      ****     PORTC &= ~0b01000000;
  23               		.loc 1 198 0
  24 0002 4698      		cbi 0x8,6
 199:matrix.c      ****     DDRD  &= ~0b00001111;
  25               		.loc 1 199 0
  26 0004 8AB1      		in r24,0xa
  27 0006 807F      		andi r24,lo8(-16)
  28 0008 8AB9      		out 0xa,r24
 200:matrix.c      ****     PORTD &= ~0b00001111;
  29               		.loc 1 200 0
  30 000a 8BB1      		in r24,0xb
  31 000c 807F      		andi r24,lo8(-16)
  32 000e 8BB9      		out 0xb,r24
  33 0010 0895      		ret
  34               		.cfi_endproc
  35               	.LFE23:
  37               		.section	.text.matrix_power_up,"ax",@progbits
  38               		.weak	matrix_power_up
  40               	matrix_power_up:
  41               	.LFB9:
  42               		.file 2 "../../common/keyboard.h"
   1:../../common/keyboard.h **** /*
   2:../../common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:../../common/keyboard.h **** 
   4:../../common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:../../common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:../../common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:../../common/keyboard.h **** (at your option) any later version.
   8:../../common/keyboard.h **** 
   9:../../common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:../../common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:../../common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:../../common/keyboard.h **** GNU General Public License for more details.
  13:../../common/keyboard.h **** 
  14:../../common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:../../common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:../../common/keyboard.h **** */
  17:../../common/keyboard.h **** 
  18:../../common/keyboard.h **** #ifndef KEYBOARD_H
  19:../../common/keyboard.h **** #define KEYBOARD_H
  20:../../common/keyboard.h **** 
  21:../../common/keyboard.h **** #include <stdbool.h>
  22:../../common/keyboard.h **** #include <stdint.h>
  23:../../common/keyboard.h **** 
  24:../../common/keyboard.h **** 
  25:../../common/keyboard.h **** #ifdef __cplusplus
  26:../../common/keyboard.h **** extern "C" {
  27:../../common/keyboard.h **** #endif
  28:../../common/keyboard.h **** 
  29:../../common/keyboard.h **** /* key matrix position */
  30:../../common/keyboard.h **** typedef struct {
  31:../../common/keyboard.h ****     uint8_t col;
  32:../../common/keyboard.h ****     uint8_t row;
  33:../../common/keyboard.h **** } keypos_t;
  34:../../common/keyboard.h **** 
  35:../../common/keyboard.h **** /* key event */
  36:../../common/keyboard.h **** typedef struct {
  37:../../common/keyboard.h ****     keypos_t key;
  38:../../common/keyboard.h ****     bool     pressed;
  39:../../common/keyboard.h ****     uint16_t time;
  40:../../common/keyboard.h **** } keyevent_t;
  41:../../common/keyboard.h **** 
  42:../../common/keyboard.h **** /* equivalent test of keypos_t */
  43:../../common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:../../common/keyboard.h **** 
  45:../../common/keyboard.h **** /* Rules for No Event:
  46:../../common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:../../common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:../../common/keyboard.h ****  */
  49:../../common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  50:../../common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
  51:../../common/keyboard.h **** static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
  52:../../common/keyboard.h **** 
  53:../../common/keyboard.h **** /* Tick event */
  54:../../common/keyboard.h **** #define TICK                    (keyevent_t){           \
  55:../../common/keyboard.h ****     .key = (keypos_t){ .row = 255, .col = 255 },           \
  56:../../common/keyboard.h ****     .pressed = false,                                   \
  57:../../common/keyboard.h ****     .time = (timer_read() | 1)                          \
  58:../../common/keyboard.h **** }
  59:../../common/keyboard.h **** 
  60:../../common/keyboard.h **** 
  61:../../common/keyboard.h **** void keyboard_init(void);
  62:../../common/keyboard.h **** void keyboard_task(void);
  63:../../common/keyboard.h **** void keyboard_set_leds(uint8_t leds);
  64:../../common/keyboard.h **** 
  65:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_up(void) {}
  43               		.loc 2 65 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49 0000 0895      		ret
  50               		.cfi_endproc
  51               	.LFE9:
  53               		.section	.text.matrix_power_down,"ax",@progbits
  54               		.weak	matrix_power_down
  56               	matrix_power_down:
  57               	.LFB10:
  66:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_down(void) {}
  58               		.loc 2 66 0
  59               		.cfi_startproc
  60               	/* prologue: function */
  61               	/* frame size = 0 */
  62               	/* stack size = 0 */
  63               	.L__stack_usage = 0
  64 0000 0895      		ret
  65               		.cfi_endproc
  66               	.LFE10:
  68               		.section	.text.matrix_rows,"ax",@progbits
  69               	.global	matrix_rows
  71               	matrix_rows:
  72               	.LFB12:
  49:matrix.c      **** {
  73               		.loc 1 49 0
  74               		.cfi_startproc
  75               	/* prologue: function */
  76               	/* frame size = 0 */
  77               	/* stack size = 0 */
  78               	.L__stack_usage = 0
  51:matrix.c      **** }
  79               		.loc 1 51 0
  80 0000 85E0      		ldi r24,lo8(5)
  81 0002 0895      		ret
  82               		.cfi_endproc
  83               	.LFE12:
  85               		.section	.text.matrix_cols,"ax",@progbits
  86               	.global	matrix_cols
  88               	matrix_cols:
  89               	.LFB13:
  55:matrix.c      **** {
  90               		.loc 1 55 0
  91               		.cfi_startproc
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 0 */
  95               	.L__stack_usage = 0
  57:matrix.c      **** }
  96               		.loc 1 57 0
  97 0000 8EE0      		ldi r24,lo8(14)
  98 0002 0895      		ret
  99               		.cfi_endproc
 100               	.LFE13:
 102               		.section	.text.matrix_init,"ax",@progbits
 103               	.global	matrix_init
 105               	matrix_init:
 106               	.LFB14:
  60:matrix.c      **** {
 107               		.loc 1 60 0
 108               		.cfi_startproc
 109               	/* prologue: function */
 110               	/* frame size = 0 */
 111               	/* stack size = 0 */
 112               	.L__stack_usage = 0
  62:matrix.c      ****     unselect_rows();
 113               		.loc 1 62 0
 114 0000 0E94 0000 		call unselect_rows
 115               	.LVL0:
 116               	.LBB23:
 117               	.LBB24:
 160:matrix.c      ****     DDRF  &= ~(1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 118               		.loc 1 160 0
 119 0004 80B3      		in r24,0x10
 120 0006 8C70      		andi r24,lo8(12)
 121 0008 80BB      		out 0x10,r24
 161:matrix.c      ****     PORTF |=  (1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 122               		.loc 1 161 0
 123 000a 81B3      		in r24,0x11
 124 000c 836F      		ori r24,lo8(-13)
 125 000e 81BB      		out 0x11,r24
 163:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 126               		.loc 1 163 0
 127 0010 84B1      		in r24,0x4
 128 0012 14B8      		out 0x4,__zero_reg__
 164:matrix.c      ****     PORTB |=  (1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 129               		.loc 1 164 0
 130 0014 85B1      		in r24,0x5
 131 0016 8FEF      		ldi r24,lo8(-1)
 132 0018 85B9      		out 0x5,r24
 166:matrix.c      ****     DDRD  &= ~(1<<7);
 133               		.loc 1 166 0
 134 001a 5798      		cbi 0xa,7
 167:matrix.c      ****     PORTD |=  (1<<7);
 135               		.loc 1 167 0
 136 001c 5F9A      		sbi 0xb,7
 137               	.LVL1:
 138 001e E0E0      		ldi r30,lo8(matrix)
 139 0020 F0E0      		ldi r31,hi8(matrix)
 140 0022 A0E0      		ldi r26,lo8(matrix_debouncing)
 141 0024 B0E0      		ldi r27,hi8(matrix_debouncing)
 142               	.LVL2:
 143               	.L8:
 144               	.LBE24:
 145               	.LBE23:
 146               	.LBB25:
  67:matrix.c      ****         matrix[i] = 0;
 147               		.loc 1 67 0 discriminator 2
 148 0026 1192      		st Z+,__zero_reg__
 149 0028 1192      		st Z+,__zero_reg__
  68:matrix.c      ****         matrix_debouncing[i] = 0;
 150               		.loc 1 68 0 discriminator 2
 151 002a 1D92      		st X+,__zero_reg__
 152 002c 1D92      		st X+,__zero_reg__
  66:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 153               		.loc 1 66 0 discriminator 2
 154 002e 80E0      		ldi r24,hi8(matrix+10)
 155 0030 E030      		cpi r30,lo8(matrix+10)
 156 0032 F807      		cpc r31,r24
 157 0034 01F4      		brne .L8
 158               	/* epilogue start */
 159               	.LBE25:
  70:matrix.c      **** }
 160               		.loc 1 70 0
 161 0036 0895      		ret
 162               		.cfi_endproc
 163               	.LFE14:
 165               		.section	.text.matrix_scan,"ax",@progbits
 166               	.global	matrix_scan
 168               	matrix_scan:
 169               	.LFB15:
  73:matrix.c      **** {
 170               		.loc 1 73 0
 171               		.cfi_startproc
 172 0000 DF92      		push r13
 173               	.LCFI0:
 174               		.cfi_def_cfa_offset 3
 175               		.cfi_offset 13, -2
 176 0002 EF92      		push r14
 177               	.LCFI1:
 178               		.cfi_def_cfa_offset 4
 179               		.cfi_offset 14, -3
 180 0004 FF92      		push r15
 181               	.LCFI2:
 182               		.cfi_def_cfa_offset 5
 183               		.cfi_offset 15, -4
 184 0006 0F93      		push r16
 185               	.LCFI3:
 186               		.cfi_def_cfa_offset 6
 187               		.cfi_offset 16, -5
 188 0008 1F93      		push r17
 189               	.LCFI4:
 190               		.cfi_def_cfa_offset 7
 191               		.cfi_offset 17, -6
 192 000a CF93      		push r28
 193               	.LCFI5:
 194               		.cfi_def_cfa_offset 8
 195               		.cfi_offset 28, -7
 196 000c DF93      		push r29
 197               	.LCFI6:
 198               		.cfi_def_cfa_offset 9
 199               		.cfi_offset 29, -8
 200               	/* prologue: function */
 201               	/* frame size = 0 */
 202               	/* stack size = 7 */
 203               	.L__stack_usage = 7
 204               	.LVL3:
  73:matrix.c      **** {
 205               		.loc 1 73 0
 206 000e C0E0      		ldi r28,lo8(matrix_debouncing)
 207 0010 D0E0      		ldi r29,hi8(matrix_debouncing)
 208               	.LBB40:
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 209               		.loc 1 74 0
 210 0012 F12C      		mov r15,__zero_reg__
 211 0014 EE24      		clr r14
 212 0016 E394      		inc r14
 213               	.LBB41:
  83:matrix.c      ****             debouncing = DEBOUNCE;
 214               		.loc 1 83 0
 215 0018 85E0      		ldi r24,lo8(5)
 216 001a D82E      		mov r13,r24
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 217               		.loc 1 81 0
 218 001c 00E0      		ldi r16,lo8(__c.2329)
 219 001e 10E0      		ldi r17,hi8(__c.2329)
 220               	.LVL4:
 221               	.L20:
 222               	.LBB42:
 223               	.LBB43:
 201:matrix.c      **** }
 202:matrix.c      **** 
 203:matrix.c      **** static void select_row(uint8_t row)
 204:matrix.c      **** {
 205:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 206:matrix.c      ****        switch (row) {
 224               		.loc 1 206 0
 225 0020 F110      		cpse r15,__zero_reg__
 226 0022 00C0      		rjmp .L11
 227               	.LVL5:
 207:matrix.c      ****            case 0:
 208:matrix.c      ****                DDRD  |= (1<<0);
 228               		.loc 1 208 0
 229 0024 509A      		sbi 0xa,0
 209:matrix.c      ****                PORTD &= ~(1<<0);
 230               		.loc 1 209 0
 231 0026 5898      		cbi 0xb,0
 232               	.LVL6:
 233               	.L11:
 234               	.LBE43:
 235               	.LBE42:
 236               	.LBB44:
 237               	.LBB45:
 238               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 239               		.loc 3 245 0
 240 0028 80EA      		ldi r24,lo8(-96)
 241 002a 8A95      		1: dec r24
 242 002c 01F4      		brne 1b
 243               	.LBE45:
 244               	.LBE44:
 245               	.LBB46:
 246               	.LBB47:
 187:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<<0)) ;
 247               		.loc 1 187 0
 248 002e 8FB1      		in r24,0xf
 249 0030 8170      		andi r24,lo8(1)
 250 0032 8E25      		eor r24,r14
 172:matrix.c      ****     return 
 251               		.loc 1 172 0
 252 0034 90E0      		ldi r25,0
 253               	.LBE47:
 254               	.LBE46:
  78:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 255               		.loc 1 78 0
 256 0036 2881      		ld r18,Y
 257 0038 3981      		ldd r19,Y+1
 258 003a 2817      		cp r18,r24
 259 003c 3907      		cpc r19,r25
 260 003e 01F0      		breq .L13
  79:matrix.c      ****             matrix_debouncing[i] = cols;
 261               		.loc 1 79 0
 262 0040 9983      		std Y+1,r25
 263 0042 8883      		st Y,r24
  80:matrix.c      ****             if (debouncing) {
 264               		.loc 1 80 0
 265 0044 8091 0000 		lds r24,debouncing
 266 0048 8823      		tst r24
 267 004a 01F0      		breq .L15
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 268               		.loc 1 81 0
 269 004c 8091 0000 		lds r24,debug_config
 270 0050 80FF      		sbrs r24,0
 271 0052 00C0      		rjmp .L16
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 272               		.loc 1 81 0 is_stmt 0 discriminator 1
 273 0054 80E0      		ldi r24,lo8(__c.2327)
 274 0056 90E0      		ldi r25,hi8(__c.2327)
 275 0058 0E94 0000 		call xputs
 276               	.LVL7:
 277               	.L16:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 278               		.loc 1 81 0 discriminator 2
 279 005c 8091 0000 		lds r24,debug_config
 280 0060 80FF      		sbrs r24,0
 281 0062 00C0      		rjmp .L17
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 282               		.loc 1 81 0 discriminator 1
 283 0064 8091 0000 		lds r24,debouncing
 284 0068 1F92      		push __zero_reg__
 285               	.LCFI7:
 286               		.cfi_def_cfa_offset 10
 287 006a 8F93      		push r24
 288               	.LCFI8:
 289               		.cfi_def_cfa_offset 11
 290 006c 1F93      		push r17
 291               	.LCFI9:
 292               		.cfi_def_cfa_offset 12
 293 006e 0F93      		push r16
 294               	.LCFI10:
 295               		.cfi_def_cfa_offset 13
 296 0070 0E94 0000 		call __xprintf
 297               	.LVL8:
 298 0074 0F90      		pop __tmp_reg__
 299 0076 0F90      		pop __tmp_reg__
 300 0078 0F90      		pop __tmp_reg__
 301 007a 0F90      		pop __tmp_reg__
 302               	.LCFI11:
 303               		.cfi_def_cfa_offset 9
 304               	.L17:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 305               		.loc 1 81 0 discriminator 2
 306 007c 8091 0000 		lds r24,debug_config
 307 0080 80FF      		sbrs r24,0
 308 0082 00C0      		rjmp .L15
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 309               		.loc 1 81 0 discriminator 1
 310 0084 80E0      		ldi r24,lo8(__c.2331)
 311 0086 90E0      		ldi r25,hi8(__c.2331)
 312 0088 0E94 0000 		call xputs
 313               	.LVL9:
 314               	.L15:
  83:matrix.c      ****             debouncing = DEBOUNCE;
 315               		.loc 1 83 0 is_stmt 1
 316 008c D092 0000 		sts debouncing,r13
 317               	.L13:
  85:matrix.c      ****         unselect_rows();
 318               		.loc 1 85 0
 319 0090 0E94 0000 		call unselect_rows
 320               	.LVL10:
 321               	.LBE41:
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 322               		.loc 1 74 0
 323 0094 F394      		inc r15
 324               	.LVL11:
 325 0096 2296      		adiw r28,2
 326 0098 95E0      		ldi r25,lo8(5)
 327 009a F912      		cpse r15,r25
 328 009c 00C0      		rjmp .L20
 329               	.LBE40:
  88:matrix.c      ****     if (debouncing) {
 330               		.loc 1 88 0
 331 009e 8091 0000 		lds r24,debouncing
 332 00a2 8823      		tst r24
 333 00a4 01F0      		breq .L22
  89:matrix.c      ****         if (--debouncing) {
 334               		.loc 1 89 0
 335 00a6 8150      		subi r24,lo8(-(-1))
 336 00a8 8093 0000 		sts debouncing,r24
 337 00ac 8823      		tst r24
 338 00ae 01F0      		breq .L23
 339               	.LVL12:
 340               	.LBB48:
 341               	.LBB49:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 342               		.loc 3 163 0
 343 00b0 8FE9      		ldi r24,lo8(3999)
 344 00b2 9FE0      		ldi r25,hi8(3999)
 345 00b4 0197      		1: sbiw r24,1
 346 00b6 01F4      		brne 1b
 347 00b8 00C0      		rjmp .
 348 00ba 0000      		nop
 349 00bc 00C0      		rjmp .L22
 350               	.LVL13:
 351               	.L23:
 352 00be A0E0      		ldi r26,lo8(matrix)
 353 00c0 B0E0      		ldi r27,hi8(matrix)
 354               	.LBE49:
 355               	.LBE48:
  89:matrix.c      ****         if (--debouncing) {
 356               		.loc 1 89 0
 357 00c2 E0E0      		ldi r30,lo8(matrix_debouncing)
 358 00c4 F0E0      		ldi r31,hi8(matrix_debouncing)
 359               	.L25:
 360               	.LBB50:
  93:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 361               		.loc 1 93 0 discriminator 2
 362 00c6 8191      		ld r24,Z+
 363 00c8 9191      		ld r25,Z+
 364 00ca 8D93      		st X+,r24
 365 00cc 9D93      		st X+,r25
 366               	.LVL14:
  92:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 367               		.loc 1 92 0 discriminator 2
 368 00ce 90E0      		ldi r25,hi8(matrix_debouncing+10)
 369 00d0 E030      		cpi r30,lo8(matrix_debouncing+10)
 370 00d2 F907      		cpc r31,r25
 371 00d4 01F4      		brne .L25
 372               	.L22:
 373               	.LBE50:
  98:matrix.c      ****     uint8_t layer = biton32(layer_state);
 374               		.loc 1 98 0
 375 00d6 6091 0000 		lds r22,layer_state
 376 00da 7091 0000 		lds r23,layer_state+1
 377 00de 8091 0000 		lds r24,layer_state+2
 378 00e2 9091 0000 		lds r25,layer_state+3
 379 00e6 0E94 0000 		call biton32
 380               	.LVL15:
  99:matrix.c      ****     switch (layer) {
 381               		.loc 1 99 0
 382 00ea 8823      		tst r24
 383 00ec 01F0      		breq .L27
 384 00ee 8330      		cpi r24,lo8(3)
 385 00f0 00F4      		brsh .L26
 102:matrix.c      ****             DDRC |= (1<<7);
 386               		.loc 1 102 0
 387 00f2 3F9A      		sbi 0x7,7
 103:matrix.c      ****             PORTC |= (1<<7);
 388               		.loc 1 103 0
 389 00f4 479A      		sbi 0x8,7
 104:matrix.c      ****             break;
 390               		.loc 1 104 0
 391 00f6 00C0      		rjmp .L26
 392               	.L27:
 106:matrix.c      ****             DDRC &= ~(1<<7);
 393               		.loc 1 106 0
 394 00f8 3F98      		cbi 0x7,7
 107:matrix.c      ****             PORTC &= ~(1<<7);
 395               		.loc 1 107 0
 396 00fa 4798      		cbi 0x8,7
 397               	.L26:
 112:matrix.c      **** }
 398               		.loc 1 112 0
 399 00fc 81E0      		ldi r24,lo8(1)
 400               	.LVL16:
 401               	/* epilogue start */
 402 00fe DF91      		pop r29
 403 0100 CF91      		pop r28
 404 0102 1F91      		pop r17
 405 0104 0F91      		pop r16
 406 0106 FF90      		pop r15
 407               	.LVL17:
 408 0108 EF90      		pop r14
 409 010a DF90      		pop r13
 410 010c 0895      		ret
 411               		.cfi_endproc
 412               	.LFE15:
 414               		.section	.text.matrix_is_modified,"ax",@progbits
 415               	.global	matrix_is_modified
 417               	matrix_is_modified:
 418               	.LFB16:
 115:matrix.c      **** {
 419               		.loc 1 115 0
 420               		.cfi_startproc
 421               	/* prologue: function */
 422               	/* frame size = 0 */
 423               	/* stack size = 0 */
 424               	.L__stack_usage = 0
 116:matrix.c      ****     if (debouncing) return false;
 425               		.loc 1 116 0
 426 0000 81E0      		ldi r24,lo8(1)
 427 0002 9091 0000 		lds r25,debouncing
 428 0006 9111      		cpse r25,__zero_reg__
 429 0008 80E0      		ldi r24,0
 430               	.L41:
 118:matrix.c      **** }
 431               		.loc 1 118 0
 432 000a 0895      		ret
 433               		.cfi_endproc
 434               	.LFE16:
 436               		.section	.text.matrix_is_on,"ax",@progbits
 437               	.global	matrix_is_on
 439               	matrix_is_on:
 440               	.LFB17:
 122:matrix.c      **** {
 441               		.loc 1 122 0
 442               		.cfi_startproc
 443               	.LVL18:
 444               	/* prologue: function */
 445               	/* frame size = 0 */
 446               	/* stack size = 0 */
 447               	.L__stack_usage = 0
 123:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 448               		.loc 1 123 0
 449 0000 E82F      		mov r30,r24
 450 0002 F0E0      		ldi r31,0
 451 0004 EE0F      		lsl r30
 452 0006 FF1F      		rol r31
 453 0008 E050      		subi r30,lo8(-(matrix))
 454 000a F040      		sbci r31,hi8(-(matrix))
 455 000c 21E0      		ldi r18,lo8(1)
 456 000e 30E0      		ldi r19,0
 457 0010 00C0      		rjmp 2f
 458               		1:
 459 0012 220F      		lsl r18
 460 0014 331F      		rol r19
 461               		2:
 462 0016 6A95      		dec r22
 463 0018 02F4      		brpl 1b
 464 001a 8081      		ld r24,Z
 465 001c 9181      		ldd r25,Z+1
 466               	.LVL19:
 467 001e 2823      		and r18,r24
 468 0020 3923      		and r19,r25
 469 0022 81E0      		ldi r24,lo8(1)
 470 0024 232B      		or r18,r19
 471 0026 01F4      		brne .L46
 472 0028 80E0      		ldi r24,0
 473               	.L46:
 124:matrix.c      **** }
 474               		.loc 1 124 0
 475 002a 0895      		ret
 476               		.cfi_endproc
 477               	.LFE17:
 479               		.section	.text.matrix_get_row,"ax",@progbits
 480               	.global	matrix_get_row
 482               	matrix_get_row:
 483               	.LFB18:
 128:matrix.c      **** {
 484               		.loc 1 128 0
 485               		.cfi_startproc
 486               	.LVL20:
 487               	/* prologue: function */
 488               	/* frame size = 0 */
 489               	/* stack size = 0 */
 490               	.L__stack_usage = 0
 129:matrix.c      ****     return matrix[row];
 491               		.loc 1 129 0
 492 0000 E82F      		mov r30,r24
 493 0002 F0E0      		ldi r31,0
 494 0004 EE0F      		lsl r30
 495 0006 FF1F      		rol r31
 496 0008 E050      		subi r30,lo8(-(matrix))
 497 000a F040      		sbci r31,hi8(-(matrix))
 130:matrix.c      **** }
 498               		.loc 1 130 0
 499 000c 8081      		ld r24,Z
 500 000e 9181      		ldd r25,Z+1
 501               	.LVL21:
 502 0010 0895      		ret
 503               		.cfi_endproc
 504               	.LFE18:
 506               		.section	.text.matrix_print,"ax",@progbits
 507               	.global	matrix_print
 509               	matrix_print:
 510               	.LFB19:
 133:matrix.c      **** {
 511               		.loc 1 133 0
 512               		.cfi_startproc
 513 0000 CF92      		push r12
 514               	.LCFI12:
 515               		.cfi_def_cfa_offset 3
 516               		.cfi_offset 12, -2
 517 0002 DF92      		push r13
 518               	.LCFI13:
 519               		.cfi_def_cfa_offset 4
 520               		.cfi_offset 13, -3
 521 0004 EF92      		push r14
 522               	.LCFI14:
 523               		.cfi_def_cfa_offset 5
 524               		.cfi_offset 14, -4
 525 0006 FF92      		push r15
 526               	.LCFI15:
 527               		.cfi_def_cfa_offset 6
 528               		.cfi_offset 15, -5
 529 0008 0F93      		push r16
 530               	.LCFI16:
 531               		.cfi_def_cfa_offset 7
 532               		.cfi_offset 16, -6
 533 000a 1F93      		push r17
 534               	.LCFI17:
 535               		.cfi_def_cfa_offset 8
 536               		.cfi_offset 17, -7
 537 000c CF93      		push r28
 538               	.LCFI18:
 539               		.cfi_def_cfa_offset 9
 540               		.cfi_offset 28, -8
 541 000e DF93      		push r29
 542               	.LCFI19:
 543               		.cfi_def_cfa_offset 10
 544               		.cfi_offset 29, -9
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547               	/* stack size = 8 */
 548               	.L__stack_usage = 8
 134:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 549               		.loc 1 134 0
 550 0010 80E0      		ldi r24,lo8(__c.2358)
 551 0012 90E0      		ldi r25,hi8(__c.2358)
 552 0014 0E94 0000 		call xputs
 553 0018 30E0      		ldi r19,lo8(matrix)
 554 001a E32E      		mov r14,r19
 555 001c 30E0      		ldi r19,hi8(matrix)
 556 001e F32E      		mov r15,r19
 557 0020 C0E0      		ldi r28,0
 558 0022 D0E0      		ldi r29,0
 559               	.LBB51:
 136:matrix.c      ****         phex(row); print(": ");
 560               		.loc 1 136 0
 561 0024 40E0      		ldi r20,lo8(__c.2361)
 562 0026 C42E      		mov r12,r20
 563 0028 40E0      		ldi r20,hi8(__c.2361)
 564 002a D42E      		mov r13,r20
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 565               		.loc 1 137 0
 566 002c 00E0      		ldi r16,lo8(__c.2365)
 567 002e 10E0      		ldi r17,hi8(__c.2365)
 568               	.L50:
 136:matrix.c      ****         phex(row); print(": ");
 569               		.loc 1 136 0 discriminator 2
 570 0030 DF93      		push r29
 571               	.LCFI20:
 572               		.cfi_def_cfa_offset 11
 573 0032 CF93      		push r28
 574               	.LCFI21:
 575               		.cfi_def_cfa_offset 12
 576 0034 DF92      		push r13
 577               	.LCFI22:
 578               		.cfi_def_cfa_offset 13
 579 0036 CF92      		push r12
 580               	.LCFI23:
 581               		.cfi_def_cfa_offset 14
 582 0038 0E94 0000 		call __xprintf
 583 003c 80E0      		ldi r24,lo8(__c.2363)
 584 003e 90E0      		ldi r25,hi8(__c.2363)
 585 0040 0E94 0000 		call xputs
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 586               		.loc 1 137 0 discriminator 2
 587 0044 F701      		movw r30,r14
 588 0046 8191      		ld r24,Z+
 589 0048 9191      		ld r25,Z+
 590 004a 7F01      		movw r14,r30
 591 004c 0E94 0000 		call bitrev16
 592 0050 9F93      		push r25
 593               	.LCFI24:
 594               		.cfi_def_cfa_offset 15
 595 0052 8F93      		push r24
 596               	.LCFI25:
 597               		.cfi_def_cfa_offset 16
 598 0054 1F93      		push r17
 599               	.LCFI26:
 600               		.cfi_def_cfa_offset 17
 601 0056 0F93      		push r16
 602               	.LCFI27:
 603               		.cfi_def_cfa_offset 18
 604 0058 0E94 0000 		call __xprintf
 138:matrix.c      ****         print("\n");
 605               		.loc 1 138 0 discriminator 2
 606 005c 80E0      		ldi r24,lo8(__c.2367)
 607 005e 90E0      		ldi r25,hi8(__c.2367)
 608 0060 0E94 0000 		call xputs
 609 0064 2196      		adiw r28,1
 135:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 610               		.loc 1 135 0 discriminator 2
 611 0066 8DB7      		in r24,__SP_L__
 612 0068 9EB7      		in r25,__SP_H__
 613 006a 0896      		adiw r24,8
 614 006c 0FB6      		in __tmp_reg__,__SREG__
 615 006e F894      		cli
 616 0070 9EBF      		out __SP_H__,r25
 617 0072 0FBE      		out __SREG__,__tmp_reg__
 618 0074 8DBF      		out __SP_L__,r24
 619               	.LCFI28:
 620               		.cfi_def_cfa_offset 10
 621 0076 C530      		cpi r28,5
 622 0078 D105      		cpc r29,__zero_reg__
 623 007a 01F4      		brne .L50
 624               	/* epilogue start */
 625               	.LBE51:
 140:matrix.c      **** }
 626               		.loc 1 140 0
 627 007c DF91      		pop r29
 628 007e CF91      		pop r28
 629 0080 1F91      		pop r17
 630 0082 0F91      		pop r16
 631 0084 FF90      		pop r15
 632 0086 EF90      		pop r14
 633 0088 DF90      		pop r13
 634 008a CF90      		pop r12
 635 008c 0895      		ret
 636               		.cfi_endproc
 637               	.LFE19:
 639               		.section	.text.matrix_key_count,"ax",@progbits
 640               	.global	matrix_key_count
 642               	matrix_key_count:
 643               	.LFB20:
 143:matrix.c      **** {
 644               		.loc 1 143 0
 645               		.cfi_startproc
 646 0000 1F93      		push r17
 647               	.LCFI29:
 648               		.cfi_def_cfa_offset 3
 649               		.cfi_offset 17, -2
 650 0002 CF93      		push r28
 651               	.LCFI30:
 652               		.cfi_def_cfa_offset 4
 653               		.cfi_offset 28, -3
 654 0004 DF93      		push r29
 655               	.LCFI31:
 656               		.cfi_def_cfa_offset 5
 657               		.cfi_offset 29, -4
 658               	/* prologue: function */
 659               	/* frame size = 0 */
 660               	/* stack size = 3 */
 661               	.L__stack_usage = 3
 662               	.LVL22:
 663 0006 C0E0      		ldi r28,lo8(matrix)
 664 0008 D0E0      		ldi r29,hi8(matrix)
 144:matrix.c      ****     uint8_t count = 0;
 665               		.loc 1 144 0
 666 000a 10E0      		ldi r17,0
 667               	.LVL23:
 668               	.L53:
 669               	.LBB52:
 146:matrix.c      ****         count += bitpop16(matrix[i]);
 670               		.loc 1 146 0 discriminator 2
 671 000c 8991      		ld r24,Y+
 672 000e 9991      		ld r25,Y+
 673 0010 0E94 0000 		call bitpop16
 674               	.LVL24:
 675 0014 180F      		add r17,r24
 676               	.LVL25:
 145:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 677               		.loc 1 145 0 discriminator 2
 678 0016 80E0      		ldi r24,hi8(matrix+10)
 679 0018 C030      		cpi r28,lo8(matrix+10)
 680 001a D807      		cpc r29,r24
 681 001c 01F4      		brne .L53
 682               	.LBE52:
 149:matrix.c      **** }
 683               		.loc 1 149 0
 684 001e 812F      		mov r24,r17
 685               	/* epilogue start */
 686 0020 DF91      		pop r29
 687 0022 CF91      		pop r28
 688 0024 1F91      		pop r17
 689               	.LVL26:
 690 0026 0895      		ret
 691               		.cfi_endproc
 692               	.LFE20:
 694               		.section	.progmem.data,"a",@progbits
 697               	__c.2367:
 698 0000 0A00      		.string	"\n"
 701               	__c.2365:
 702 0002 2530 3136 		.string	"%016b"
 702      6200 
 705               	__c.2363:
 706 0008 3A20 00   		.string	": "
 709               	__c.2361:
 710 000b 2530 3258 		.string	"%02X"
 710      00
 713               	__c.2358:
 714 0010 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 714      2030 3132 
 714      3334 3536 
 714      3738 3941 
 714      4243 4445 
 717               	__c.2331:
 718 0027 0A00      		.string	"\n"
 721               	__c.2329:
 722 0029 2530 3258 		.string	"%02X"
 722      00
 725               	__c.2327:
 726 002e 626F 756E 		.string	"bounce!: "
 726      6365 213A 
 726      2000 
 727               		.local	matrix_debouncing
 728               		.comm	matrix_debouncing,10,1
 729               		.local	matrix
 730               		.comm	matrix,10,1
 731               		.data
 734               	debouncing:
 735 0000 05        		.byte	5
 736               		.text
 737               	.Letext0:
 738               		.file 4 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 739               		.file 5 "../../common/debug.h"
 740               		.file 6 "../../common/matrix.h"
 741               		.file 7 "../../common/action_layer.h"
 742               		.file 8 "../../common/avr/xprintf.h"
 743               		.file 9 "../../common/util.h"
DEFINED SYMBOLS
                            *ABS*:00000000 matrix.c
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:2      *ABS*:0000003e __SP_H__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:3      *ABS*:0000003d __SP_L__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:4      *ABS*:0000003f __SREG__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:6      *ABS*:00000001 __zero_reg__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:12     .text.unselect_rows:00000000 unselect_rows
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:40     .text.matrix_power_up:00000000 matrix_power_up
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:56     .text.matrix_power_down:00000000 matrix_power_down
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:71     .text.matrix_rows:00000000 matrix_rows
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:88     .text.matrix_cols:00000000 matrix_cols
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:105    .text.matrix_init:00000000 matrix_init
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:728    .bss:0000000a matrix
                             .bss:00000000 matrix_debouncing
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:168    .text.matrix_scan:00000000 matrix_scan
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:721    .progmem.data:00000029 __c.2329
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:734    .data:00000000 debouncing
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:725    .progmem.data:0000002e __c.2327
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:717    .progmem.data:00000027 __c.2331
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:417    .text.matrix_is_modified:00000000 matrix_is_modified
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:439    .text.matrix_is_on:00000000 matrix_is_on
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:482    .text.matrix_get_row:00000000 matrix_get_row
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:509    .text.matrix_print:00000000 matrix_print
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:713    .progmem.data:00000010 __c.2358
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:709    .progmem.data:0000000b __c.2361
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:701    .progmem.data:00000002 __c.2365
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:705    .progmem.data:00000008 __c.2363
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:697    .progmem.data:00000000 __c.2367
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//cc46eoNM.s:642    .text.matrix_key_count:00000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
layer_state
biton32
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
