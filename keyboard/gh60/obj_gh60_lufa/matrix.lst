   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB21:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "action_layer.h"
  26:matrix.c      **** #include "print.h"
  27:matrix.c      **** #include "debug.h"
  28:matrix.c      **** #include "util.h"
  29:matrix.c      **** #include "matrix.h"
  30:matrix.c      **** 
  31:matrix.c      **** 
  32:matrix.c      **** #ifndef DEBOUNCE
  33:matrix.c      **** #   define DEBOUNCE	10
  34:matrix.c      **** #endif
  35:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  36:matrix.c      **** 
  37:matrix.c      **** /* matrix state(1:on, 0:off) */
  38:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  39:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  40:matrix.c      **** 
  41:matrix.c      **** static matrix_row_t read_cols(void);
  42:matrix.c      **** static void init_cols(void);
  43:matrix.c      **** static void unselect_rows(void);
  44:matrix.c      **** static void select_row(uint8_t row);
  45:matrix.c      **** 
  46:matrix.c      **** 
  47:matrix.c      **** inline
  48:matrix.c      **** uint8_t matrix_rows(void)
  49:matrix.c      **** {
  50:matrix.c      ****     return MATRIX_ROWS;
  51:matrix.c      **** }
  52:matrix.c      **** 
  53:matrix.c      **** inline
  54:matrix.c      **** uint8_t matrix_cols(void)
  55:matrix.c      **** {
  56:matrix.c      ****     return MATRIX_COLS;
  57:matrix.c      **** }
  58:matrix.c      **** 
  59:matrix.c      **** void matrix_init(void)
  60:matrix.c      **** {
  61:matrix.c      ****     // initialize row and col
  62:matrix.c      ****     unselect_rows();
  63:matrix.c      ****     init_cols();
  64:matrix.c      **** 
  65:matrix.c      ****     // initialize matrix state: all keys off
  66:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  67:matrix.c      ****         matrix[i] = 0;
  68:matrix.c      ****         matrix_debouncing[i] = 0;
  69:matrix.c      ****     }
  70:matrix.c      **** }
  71:matrix.c      **** 
  72:matrix.c      **** uint8_t matrix_scan(void)
  73:matrix.c      **** {
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  75:matrix.c      ****         select_row(i);
  76:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  77:matrix.c      ****         matrix_row_t cols = read_cols();
  78:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  79:matrix.c      ****             matrix_debouncing[i] = cols;
  80:matrix.c      ****             if (debouncing) {
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  82:matrix.c      ****             }
  83:matrix.c      ****             debouncing = DEBOUNCE;
  84:matrix.c      ****         }
  85:matrix.c      ****         unselect_rows();
  86:matrix.c      ****     }
  87:matrix.c      **** 
  88:matrix.c      ****     if (debouncing) {
  89:matrix.c      ****         if (--debouncing) {
  90:matrix.c      ****             _delay_ms(1);
  91:matrix.c      ****         } else {
  92:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  93:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  94:matrix.c      ****             }
  95:matrix.c      ****         }
  96:matrix.c      ****     }
  97:matrix.c      **** 
  98:matrix.c      ****     uint8_t layer = biton32(layer_state);
  99:matrix.c      ****     switch (layer) {
 100:matrix.c      ****         case 1:
 101:matrix.c      ****         case 2:
 102:matrix.c      ****             DDRC |= (1<<7);
 103:matrix.c      ****             PORTC |= (1<<7);
 104:matrix.c      ****             break;
 105:matrix.c      ****         case 0:
 106:matrix.c      ****             DDRC &= ~(1<<7);
 107:matrix.c      ****             PORTC &= ~(1<<7);
 108:matrix.c      ****             break;
 109:matrix.c      ****     }
 110:matrix.c      **** 
 111:matrix.c      ****     return 1;
 112:matrix.c      **** }
 113:matrix.c      **** 
 114:matrix.c      **** bool matrix_is_modified(void)
 115:matrix.c      **** {
 116:matrix.c      ****     if (debouncing) return false;
 117:matrix.c      ****     return true;
 118:matrix.c      **** }
 119:matrix.c      **** 
 120:matrix.c      **** inline
 121:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 122:matrix.c      **** {
 123:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 124:matrix.c      **** }
 125:matrix.c      **** 
 126:matrix.c      **** inline
 127:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 128:matrix.c      **** {
 129:matrix.c      ****     return matrix[row];
 130:matrix.c      **** }
 131:matrix.c      **** 
 132:matrix.c      **** void matrix_print(void)
 133:matrix.c      **** {
 134:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 135:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 136:matrix.c      ****         phex(row); print(": ");
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 138:matrix.c      ****         print("\n");
 139:matrix.c      ****     }
 140:matrix.c      **** }
 141:matrix.c      **** 
 142:matrix.c      **** uint8_t matrix_key_count(void)
 143:matrix.c      **** {
 144:matrix.c      ****     uint8_t count = 0;
 145:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 146:matrix.c      ****         count += bitpop16(matrix[i]);
 147:matrix.c      ****     }
 148:matrix.c      ****     return count;
 149:matrix.c      **** }
 150:matrix.c      **** 
 151:matrix.c      **** /* Column pin configuration
 152:matrix.c      ****  * col: 0  1  2  3  4  5  6  7  8  9  10 11
 153:matrix.c      ****  * pin: F0 F1 F4 F5 F6 F7 B6 B5 B4 D7 D5 D4
 154:matrix.c      ****  */
 155:matrix.c      **** 
 156:matrix.c      **** static void init_cols(void)
 157:matrix.c      **** {
 158:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 159:matrix.c      ****     DDRF  &= ~(1<<7);
 160:matrix.c      ****     PORTF |=  (1<<7);
 161:matrix.c      ****     DDRB  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1);
 162:matrix.c      ****     PORTB |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1);
 163:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<3 | 1<<2 | 1<<1 | 1<<0 );
 164:matrix.c      ****     PORTD |=  (1<<7 | 1<<3 | 1<<2 | 1<<1 | 1<<0 );
 165:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6);
 166:matrix.c      ****     PORTC |=  (1<<7 | 1<<6);
 167:matrix.c      **** }
 168:matrix.c      **** 
 169:matrix.c      **** static matrix_row_t read_cols(void)
 170:matrix.c      **** {
 171:matrix.c      ****     return 
 172:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<< 0)) |
 173:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<< 1)) |
 174:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<< 2)) |
 175:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<< 3)) |
 176:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<< 4)) |
 177:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<< 5)) |
 178:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<< 6)) |
 179:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<< 7)) |
 180:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<< 8)) |
 181:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<< 9)) |
 182:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<10)) |
 183:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<11)) |
 184:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<12)) |
 185:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<13)) |
 186:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<14));
 187:matrix.c      **** }
 188:matrix.c      **** 
 189:matrix.c      **** /* Row pin configuration
 190:matrix.c      ****  * row: 0  1  2  3
 191:matrix.c      ****  * pin: B0 B1 B2 B3
 192:matrix.c      ****  */
 193:matrix.c      **** static void unselect_rows(void)
 194:matrix.c      **** {
  15               		.loc 1 194 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 195:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 196:matrix.c      ****     DDRB  &= ~0b01110000;
  21               		.loc 1 196 0
  22 0000 84B1      		in r24,0x4
  23 0002 8F78      		andi r24,lo8(-113)
  24 0004 84B9      		out 0x4,r24
 197:matrix.c      ****     PORTB &= ~0b01110000;
  25               		.loc 1 197 0
  26 0006 85B1      		in r24,0x5
  27 0008 8F78      		andi r24,lo8(-113)
  28 000a 85B9      		out 0x5,r24
 198:matrix.c      ****     DDRD  &= ~0b10000000;
  29               		.loc 1 198 0
  30 000c 5798      		cbi 0xa,7
 199:matrix.c      ****     PORTD &= ~0b10000000;
  31               		.loc 1 199 0
  32 000e 5F98      		cbi 0xb,7
  33 0010 0895      		ret
  34               		.cfi_endproc
  35               	.LFE21:
  37               		.section	.text.matrix_rows,"ax",@progbits
  38               	.global	matrix_rows
  40               	matrix_rows:
  41               	.LFB10:
  49:matrix.c      **** {
  42               		.loc 1 49 0
  43               		.cfi_startproc
  44               	/* prologue: function */
  45               	/* frame size = 0 */
  46               	/* stack size = 0 */
  47               	.L__stack_usage = 0
  51:matrix.c      **** }
  48               		.loc 1 51 0
  49 0000 85E0      		ldi r24,lo8(5)
  50 0002 0895      		ret
  51               		.cfi_endproc
  52               	.LFE10:
  54               		.section	.text.matrix_cols,"ax",@progbits
  55               	.global	matrix_cols
  57               	matrix_cols:
  58               	.LFB11:
  55:matrix.c      **** {
  59               		.loc 1 55 0
  60               		.cfi_startproc
  61               	/* prologue: function */
  62               	/* frame size = 0 */
  63               	/* stack size = 0 */
  64               	.L__stack_usage = 0
  57:matrix.c      **** }
  65               		.loc 1 57 0
  66 0000 8EE0      		ldi r24,lo8(14)
  67 0002 0895      		ret
  68               		.cfi_endproc
  69               	.LFE11:
  71               		.section	.text.matrix_init,"ax",@progbits
  72               	.global	matrix_init
  74               	matrix_init:
  75               	.LFB12:
  60:matrix.c      **** {
  76               		.loc 1 60 0
  77               		.cfi_startproc
  78               	/* prologue: function */
  79               	/* frame size = 0 */
  80               	/* stack size = 0 */
  81               	.L__stack_usage = 0
  62:matrix.c      ****     unselect_rows();
  82               		.loc 1 62 0
  83 0000 0E94 0000 		call unselect_rows
  84               	.LVL0:
  85               	.LBB23:
  86               	.LBB24:
 159:matrix.c      ****     DDRF  &= ~(1<<7);
  87               		.loc 1 159 0
  88 0004 8798      		cbi 0x10,7
 160:matrix.c      ****     PORTF |=  (1<<7);
  89               		.loc 1 160 0
  90 0006 8F9A      		sbi 0x11,7
 161:matrix.c      ****     DDRB  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1);
  91               		.loc 1 161 0
  92 0008 84B1      		in r24,0x4
  93 000a 8170      		andi r24,lo8(1)
  94 000c 84B9      		out 0x4,r24
 162:matrix.c      ****     PORTB |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1);
  95               		.loc 1 162 0
  96 000e 85B1      		in r24,0x5
  97 0010 8E6F      		ori r24,lo8(-2)
  98 0012 85B9      		out 0x5,r24
 163:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<3 | 1<<2 | 1<<1 | 1<<0 );
  99               		.loc 1 163 0
 100 0014 8AB1      		in r24,0xa
 101 0016 8077      		andi r24,lo8(112)
 102 0018 8AB9      		out 0xa,r24
 164:matrix.c      ****     PORTD |=  (1<<7 | 1<<3 | 1<<2 | 1<<1 | 1<<0 );
 103               		.loc 1 164 0
 104 001a 8BB1      		in r24,0xb
 105 001c 8F68      		ori r24,lo8(-113)
 106 001e 8BB9      		out 0xb,r24
 165:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6);
 107               		.loc 1 165 0
 108 0020 87B1      		in r24,0x7
 109 0022 8F73      		andi r24,lo8(63)
 110 0024 87B9      		out 0x7,r24
 166:matrix.c      ****     PORTC |=  (1<<7 | 1<<6);
 111               		.loc 1 166 0
 112 0026 88B1      		in r24,0x8
 113 0028 806C      		ori r24,lo8(-64)
 114 002a 88B9      		out 0x8,r24
 115               	.LVL1:
 116 002c E0E0      		ldi r30,lo8(matrix)
 117 002e F0E0      		ldi r31,hi8(matrix)
 118 0030 A0E0      		ldi r26,lo8(matrix_debouncing)
 119 0032 B0E0      		ldi r27,hi8(matrix_debouncing)
 120               	.LVL2:
 121               	.L6:
 122               	.LBE24:
 123               	.LBE23:
 124               	.LBB25:
  67:matrix.c      ****         matrix[i] = 0;
 125               		.loc 1 67 0 discriminator 2
 126 0034 1192      		st Z+,__zero_reg__
 127 0036 1192      		st Z+,__zero_reg__
  68:matrix.c      ****         matrix_debouncing[i] = 0;
 128               		.loc 1 68 0 discriminator 2
 129 0038 1D92      		st X+,__zero_reg__
 130 003a 1D92      		st X+,__zero_reg__
  66:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 131               		.loc 1 66 0 discriminator 2
 132 003c 80E0      		ldi r24,hi8(matrix+10)
 133 003e E030      		cpi r30,lo8(matrix+10)
 134 0040 F807      		cpc r31,r24
 135 0042 01F4      		brne .L6
 136               	/* epilogue start */
 137               	.LBE25:
  70:matrix.c      **** }
 138               		.loc 1 70 0
 139 0044 0895      		ret
 140               		.cfi_endproc
 141               	.LFE12:
 143               		.section	.text.matrix_scan,"ax",@progbits
 144               	.global	matrix_scan
 146               	matrix_scan:
 147               	.LFB13:
  73:matrix.c      **** {
 148               		.loc 1 73 0
 149               		.cfi_startproc
 150 0000 EF92      		push r14
 151               	.LCFI0:
 152               		.cfi_def_cfa_offset 3
 153               		.cfi_offset 14, -2
 154 0002 FF92      		push r15
 155               	.LCFI1:
 156               		.cfi_def_cfa_offset 4
 157               		.cfi_offset 15, -3
 158 0004 0F93      		push r16
 159               	.LCFI2:
 160               		.cfi_def_cfa_offset 5
 161               		.cfi_offset 16, -4
 162 0006 1F93      		push r17
 163               	.LCFI3:
 164               		.cfi_def_cfa_offset 6
 165               		.cfi_offset 17, -5
 166 0008 CF93      		push r28
 167               	.LCFI4:
 168               		.cfi_def_cfa_offset 7
 169               		.cfi_offset 28, -6
 170 000a DF93      		push r29
 171               	.LCFI5:
 172               		.cfi_def_cfa_offset 8
 173               		.cfi_offset 29, -7
 174               	/* prologue: function */
 175               	/* frame size = 0 */
 176               	/* stack size = 6 */
 177               	.L__stack_usage = 6
 178               	.LVL3:
  73:matrix.c      **** {
 179               		.loc 1 73 0
 180 000c C0E0      		ldi r28,lo8(matrix_debouncing)
 181 000e D0E0      		ldi r29,hi8(matrix_debouncing)
 182               	.LBB40:
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 183               		.loc 1 74 0
 184 0010 10E0      		ldi r17,0
 185 0012 01E0      		ldi r16,lo8(1)
 186               	.LBB41:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 187               		.loc 1 81 0
 188 0014 A0E0      		ldi r26,lo8(__c.2327)
 189 0016 EA2E      		mov r14,r26
 190 0018 A0E0      		ldi r26,hi8(__c.2327)
 191 001a FA2E      		mov r15,r26
 192               	.LVL4:
 193               	.L37:
 194               	.LBB42:
 195               	.LBB43:
 200:matrix.c      **** }
 201:matrix.c      **** 
 202:matrix.c      **** static void select_row(uint8_t row)
 203:matrix.c      **** {
 204:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 205:matrix.c      ****        switch (row) {
 196               		.loc 1 205 0
 197 001c 1230      		cpi r17,lo8(2)
 198 001e 01F0      		breq .L10
 199 0020 00F4      		brsh .L11
 200 0022 1130      		cpi r17,lo8(1)
 201 0024 01F0      		breq .L12
 202 0026 00C0      		rjmp .L9
 203               	.L11:
 204 0028 1330      		cpi r17,lo8(3)
 205 002a 01F0      		breq .L13
 206 002c 1430      		cpi r17,lo8(4)
 207 002e 01F0      		breq .L14
 208               	.L9:
 206:matrix.c      ****            case 0:
 207:matrix.c      ****                DDRD  |= (1<<0);
 209               		.loc 1 207 0
 210 0030 509A      		sbi 0xa,0
 208:matrix.c      ****                PORTD &= ~(1<<0);
 211               		.loc 1 208 0
 212 0032 5898      		cbi 0xb,0
 213 0034 00C0      		rjmp .L15
 214               	.L12:
 209:matrix.c      ****                break;
 210:matrix.c      ****            case 1:
 211:matrix.c      ****                DDRD  |= (1<<1);
 215               		.loc 1 211 0
 216 0036 519A      		sbi 0xa,1
 212:matrix.c      ****                PORTD &= ~(1<<1);
 217               		.loc 1 212 0
 218 0038 5998      		cbi 0xb,1
 219 003a 00C0      		rjmp .L15
 220               	.L10:
 213:matrix.c      ****                break;
 214:matrix.c      ****            case 2:
 215:matrix.c      ****                DDRD  |= (1<<2);
 221               		.loc 1 215 0
 222 003c 529A      		sbi 0xa,2
 216:matrix.c      ****                PORTD &= ~(1<<2);
 223               		.loc 1 216 0
 224 003e 5A98      		cbi 0xb,2
 225 0040 00C0      		rjmp .L15
 226               	.L13:
 217:matrix.c      ****                break;
 218:matrix.c      ****            case 3:
 219:matrix.c      ****                DDRD  |= (1<<3);
 227               		.loc 1 219 0
 228 0042 539A      		sbi 0xa,3
 220:matrix.c      ****                PORTD &= ~(1<<3);
 229               		.loc 1 220 0
 230 0044 5B98      		cbi 0xb,3
 231 0046 00C0      		rjmp .L15
 232               	.L14:
 221:matrix.c      ****                break;
 222:matrix.c      ****            case 4:
 223:matrix.c      ****                DDRC  |= (1<<6);
 233               		.loc 1 223 0
 234 0048 3E9A      		sbi 0x7,6
 224:matrix.c      ****                PORTC &= ~(1<<6);
 235               		.loc 1 224 0
 236 004a 4698      		cbi 0x8,6
 237               	.L15:
 238               	.LVL5:
 239               	.LBE43:
 240               	.LBE42:
 241               	.LBB44:
 242               	.LBB45:
 243               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 244               		.loc 2 245 0
 245 004c 80EA      		ldi r24,lo8(-96)
 246 004e 8A95      		1: dec r24
 247 0050 01F4      		brne 1b
 248               	.LBE45:
 249               	.LBE44:
 250               	.LBB46:
 251               	.LBB47:
 172:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<< 0)) |
 252               		.loc 1 172 0
 253 0052 2FB1      		in r18,0xf
 254 0054 2170      		andi r18,lo8(1)
 255 0056 2027      		eor r18,r16
 256 0058 30E0      		ldi r19,0
 173:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<< 1)) |
 257               		.loc 1 173 0
 258 005a 799B      		sbis 0xf,1
 259 005c 00C0      		rjmp .L46
 260 005e 80E0      		ldi r24,0
 261 0060 90E0      		ldi r25,0
 262 0062 00C0      		rjmp .L16
 263               	.L46:
 264 0064 82E0      		ldi r24,lo8(2)
 265 0066 90E0      		ldi r25,0
 266               	.L16:
 172:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<< 0)) |
 267               		.loc 1 172 0
 268 0068 282B      		or r18,r24
 269 006a 392B      		or r19,r25
 174:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<< 2)) |
 270               		.loc 1 174 0
 271 006c 7C9B      		sbis 0xf,4
 272 006e 00C0      		rjmp .L47
 273 0070 40E0      		ldi r20,0
 274 0072 50E0      		ldi r21,0
 275 0074 00C0      		rjmp .L17
 276               	.L47:
 277 0076 44E0      		ldi r20,lo8(4)
 278 0078 50E0      		ldi r21,0
 279               	.L17:
 173:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<< 1)) |
 280               		.loc 1 173 0
 281 007a 242B      		or r18,r20
 282 007c 352B      		or r19,r21
 175:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<< 3)) |
 283               		.loc 1 175 0
 284 007e 7D9B      		sbis 0xf,5
 285 0080 00C0      		rjmp .L48
 286 0082 80E0      		ldi r24,0
 287 0084 90E0      		ldi r25,0
 288 0086 00C0      		rjmp .L18
 289               	.L48:
 290 0088 88E0      		ldi r24,lo8(8)
 291 008a 90E0      		ldi r25,0
 292               	.L18:
 174:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<< 2)) |
 293               		.loc 1 174 0
 294 008c 282B      		or r18,r24
 295 008e 392B      		or r19,r25
 176:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<< 4)) |
 296               		.loc 1 176 0
 297 0090 7E9B      		sbis 0xf,6
 298 0092 00C0      		rjmp .L49
 299 0094 80E0      		ldi r24,0
 300 0096 90E0      		ldi r25,0
 301 0098 00C0      		rjmp .L19
 302               	.L49:
 303 009a 80E1      		ldi r24,lo8(16)
 304 009c 90E0      		ldi r25,0
 305               	.L19:
 175:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<< 3)) |
 306               		.loc 1 175 0
 307 009e 282B      		or r18,r24
 308 00a0 392B      		or r19,r25
 177:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<< 5)) |
 309               		.loc 1 177 0
 310 00a2 8FB1      		in r24,0xf
 311 00a4 9927      		clr r25
 312 00a6 87FD      		sbrc r24,7
 313 00a8 9095      		com r25
 314 00aa 8095      		com r24
 315 00ac 9095      		com r25
 316 00ae 8827      		clr r24
 317 00b0 990F      		lsl r25
 318 00b2 881F      		rol r24
 319 00b4 9927      		clr r25
 320 00b6 F5E0      		ldi r31,5
 321               		1:
 322 00b8 880F      		lsl r24
 323 00ba 991F      		rol r25
 324 00bc FA95      		dec r31
 325 00be 01F4      		brne 1b
 176:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<< 4)) |
 326               		.loc 1 176 0
 327 00c0 282B      		or r18,r24
 328 00c2 392B      		or r19,r25
 178:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<< 6)) |
 329               		.loc 1 178 0
 330 00c4 1E9B      		sbis 0x3,6
 331 00c6 00C0      		rjmp .L51
 332 00c8 80E0      		ldi r24,0
 333 00ca 90E0      		ldi r25,0
 334 00cc 00C0      		rjmp .L21
 335               	.L51:
 336 00ce 80E4      		ldi r24,lo8(64)
 337 00d0 90E0      		ldi r25,0
 338               	.L21:
 177:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<< 5)) |
 339               		.loc 1 177 0
 340 00d2 282B      		or r18,r24
 341 00d4 392B      		or r19,r25
 179:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<< 7)) |
 342               		.loc 1 179 0
 343 00d6 1D9B      		sbis 0x3,5
 344 00d8 00C0      		rjmp .L52
 345 00da 80E0      		ldi r24,0
 346 00dc 90E0      		ldi r25,0
 347 00de 00C0      		rjmp .L22
 348               	.L52:
 349 00e0 80E8      		ldi r24,lo8(-128)
 350 00e2 90E0      		ldi r25,0
 351               	.L22:
 178:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<< 6)) |
 352               		.loc 1 178 0
 353 00e4 282B      		or r18,r24
 354 00e6 392B      		or r19,r25
 180:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<< 8)) |
 355               		.loc 1 180 0
 356 00e8 1C9B      		sbis 0x3,4
 357 00ea 00C0      		rjmp .L53
 358 00ec 80E0      		ldi r24,0
 359 00ee 90E0      		ldi r25,0
 360 00f0 00C0      		rjmp .L23
 361               	.L53:
 362 00f2 80E0      		ldi r24,0
 363 00f4 91E0      		ldi r25,lo8(1)
 364               	.L23:
 179:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<< 7)) |
 365               		.loc 1 179 0
 366 00f6 282B      		or r18,r24
 367 00f8 392B      		or r19,r25
 181:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<< 9)) |
 368               		.loc 1 181 0
 369 00fa 89B1      		in r24,0x9
 370 00fc 9927      		clr r25
 371 00fe 87FD      		sbrc r24,7
 372 0100 9095      		com r25
 373 0102 8095      		com r24
 374 0104 9095      		com r25
 375 0106 8827      		clr r24
 376 0108 990F      		lsl r25
 377 010a 881F      		rol r24
 378 010c 9927      		clr r25
 379 010e 982F      		mov r25,r24
 380 0110 8827      		clr r24
 381 0112 990F      		lsl r25
 180:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<< 8)) |
 382               		.loc 1 180 0
 383 0114 282B      		or r18,r24
 384 0116 392B      		or r19,r25
 182:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<10)) |
 385               		.loc 1 182 0
 386 0118 189B      		sbis 0x3,0
 387 011a 00C0      		rjmp .L55
 388 011c 40E0      		ldi r20,0
 389 011e 50E0      		ldi r21,0
 390 0120 00C0      		rjmp .L25
 391               	.L55:
 392 0122 40E0      		ldi r20,0
 393 0124 54E0      		ldi r21,lo8(4)
 394               	.L25:
 181:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<< 9)) |
 395               		.loc 1 181 0
 396 0126 242B      		or r18,r20
 397 0128 352B      		or r19,r21
 183:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<11)) |
 398               		.loc 1 183 0
 399 012a 199B      		sbis 0x3,1
 400 012c 00C0      		rjmp .L56
 401 012e 40E0      		ldi r20,0
 402 0130 50E0      		ldi r21,0
 403 0132 00C0      		rjmp .L26
 404               	.L56:
 405 0134 40E0      		ldi r20,0
 406 0136 58E0      		ldi r21,lo8(8)
 407               	.L26:
 182:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<10)) |
 408               		.loc 1 182 0
 409 0138 242B      		or r18,r20
 410 013a 352B      		or r19,r21
 184:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<12)) |
 411               		.loc 1 184 0
 412 013c 1A9B      		sbis 0x3,2
 413 013e 00C0      		rjmp .L57
 414 0140 80E0      		ldi r24,0
 415 0142 90E0      		ldi r25,0
 416 0144 00C0      		rjmp .L27
 417               	.L57:
 418 0146 80E0      		ldi r24,0
 419 0148 90E1      		ldi r25,lo8(16)
 420               	.L27:
 183:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<11)) |
 421               		.loc 1 183 0
 422 014a 282B      		or r18,r24
 423 014c 392B      		or r19,r25
 185:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<13)) |
 424               		.loc 1 185 0
 425 014e 1B9B      		sbis 0x3,3
 426 0150 00C0      		rjmp .L58
 427 0152 80E0      		ldi r24,0
 428 0154 90E0      		ldi r25,0
 429 0156 00C0      		rjmp .L28
 430               	.L58:
 431 0158 80E0      		ldi r24,0
 432 015a 90E2      		ldi r25,lo8(32)
 433               	.L28:
 184:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<12)) |
 434               		.loc 1 184 0
 435 015c 282B      		or r18,r24
 436 015e 392B      		or r19,r25
 186:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<14));
 437               		.loc 1 186 0
 438 0160 83B1      		in r24,0x3
 439 0162 9927      		clr r25
 440 0164 87FD      		sbrc r24,7
 441 0166 9095      		com r25
 442 0168 8095      		com r24
 443 016a 9095      		com r25
 444 016c 8827      		clr r24
 445 016e 990F      		lsl r25
 446 0170 881F      		rol r24
 447 0172 9927      		clr r25
 448 0174 90E4      		ldi r25,0x40
 449 0176 899F      		mul r24,r25
 450 0178 902D      		mov r25,r0
 451 017a 8827      		clr r24
 452 017c 1124      		clr __zero_reg__
 185:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<13)) |
 453               		.loc 1 185 0
 454 017e 282B      		or r18,r24
 455 0180 392B      		or r19,r25
 456               	.LBE47:
 457               	.LBE46:
  78:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 458               		.loc 1 78 0
 459 0182 8881      		ld r24,Y
 460 0184 9981      		ldd r25,Y+1
 461 0186 8217      		cp r24,r18
 462 0188 9307      		cpc r25,r19
 463 018a 01F0      		breq .L30
  79:matrix.c      ****             matrix_debouncing[i] = cols;
 464               		.loc 1 79 0
 465 018c 3983      		std Y+1,r19
 466 018e 2883      		st Y,r18
  80:matrix.c      ****             if (debouncing) {
 467               		.loc 1 80 0
 468 0190 8091 0000 		lds r24,debouncing
 469 0194 8823      		tst r24
 470 0196 01F0      		breq .L32
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 471               		.loc 1 81 0
 472 0198 8091 0000 		lds r24,debug_config
 473 019c 80FF      		sbrs r24,0
 474 019e 00C0      		rjmp .L33
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 475               		.loc 1 81 0 is_stmt 0 discriminator 1
 476 01a0 80E0      		ldi r24,lo8(__c.2325)
 477 01a2 90E0      		ldi r25,hi8(__c.2325)
 478 01a4 0E94 0000 		call xputs
 479               	.LVL6:
 480               	.L33:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 481               		.loc 1 81 0 discriminator 2
 482 01a8 8091 0000 		lds r24,debug_config
 483 01ac 80FF      		sbrs r24,0
 484 01ae 00C0      		rjmp .L34
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 485               		.loc 1 81 0 discriminator 1
 486 01b0 8091 0000 		lds r24,debouncing
 487 01b4 1F92      		push __zero_reg__
 488               	.LCFI6:
 489               		.cfi_def_cfa_offset 9
 490 01b6 8F93      		push r24
 491               	.LCFI7:
 492               		.cfi_def_cfa_offset 10
 493 01b8 FF92      		push r15
 494               	.LCFI8:
 495               		.cfi_def_cfa_offset 11
 496 01ba EF92      		push r14
 497               	.LCFI9:
 498               		.cfi_def_cfa_offset 12
 499 01bc 0E94 0000 		call __xprintf
 500               	.LVL7:
 501 01c0 0F90      		pop __tmp_reg__
 502 01c2 0F90      		pop __tmp_reg__
 503 01c4 0F90      		pop __tmp_reg__
 504 01c6 0F90      		pop __tmp_reg__
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 8
 507               	.L34:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 508               		.loc 1 81 0 discriminator 2
 509 01c8 8091 0000 		lds r24,debug_config
 510 01cc 80FF      		sbrs r24,0
 511 01ce 00C0      		rjmp .L32
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 512               		.loc 1 81 0 discriminator 1
 513 01d0 80E0      		ldi r24,lo8(__c.2329)
 514 01d2 90E0      		ldi r25,hi8(__c.2329)
 515 01d4 0E94 0000 		call xputs
 516               	.LVL8:
 517               	.L32:
  83:matrix.c      ****             debouncing = DEBOUNCE;
 518               		.loc 1 83 0 is_stmt 1
 519 01d8 85E0      		ldi r24,lo8(5)
 520 01da 8093 0000 		sts debouncing,r24
 521               	.L30:
  85:matrix.c      ****         unselect_rows();
 522               		.loc 1 85 0
 523 01de 0E94 0000 		call unselect_rows
 524               	.LVL9:
 525               	.LBE41:
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 526               		.loc 1 74 0
 527 01e2 1F5F      		subi r17,lo8(-(1))
 528               	.LVL10:
 529 01e4 2296      		adiw r28,2
 530 01e6 1530      		cpi r17,lo8(5)
 531 01e8 01F0      		breq .+2
 532 01ea 00C0      		rjmp .L37
 533               	.LBE40:
  88:matrix.c      ****     if (debouncing) {
 534               		.loc 1 88 0
 535 01ec 8091 0000 		lds r24,debouncing
 536 01f0 8823      		tst r24
 537 01f2 01F0      		breq .L39
  89:matrix.c      ****         if (--debouncing) {
 538               		.loc 1 89 0
 539 01f4 8150      		subi r24,lo8(-(-1))
 540 01f6 8093 0000 		sts debouncing,r24
 541 01fa 8823      		tst r24
 542 01fc 01F0      		breq .L40
 543               	.LVL11:
 544               	.LBB48:
 545               	.LBB49:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 546               		.loc 2 163 0
 547 01fe 8FE9      		ldi r24,lo8(3999)
 548 0200 9FE0      		ldi r25,hi8(3999)
 549 0202 0197      		1: sbiw r24,1
 550 0204 01F4      		brne 1b
 551 0206 00C0      		rjmp .
 552 0208 0000      		nop
 553 020a 00C0      		rjmp .L39
 554               	.LVL12:
 555               	.L40:
 556 020c A0E0      		ldi r26,lo8(matrix)
 557 020e B0E0      		ldi r27,hi8(matrix)
 558               	.LBE49:
 559               	.LBE48:
  89:matrix.c      ****         if (--debouncing) {
 560               		.loc 1 89 0
 561 0210 E0E0      		ldi r30,lo8(matrix_debouncing)
 562 0212 F0E0      		ldi r31,hi8(matrix_debouncing)
 563               	.L42:
 564               	.LBB50:
  93:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 565               		.loc 1 93 0 discriminator 2
 566 0214 8191      		ld r24,Z+
 567 0216 9191      		ld r25,Z+
 568 0218 8D93      		st X+,r24
 569 021a 9D93      		st X+,r25
 570               	.LVL13:
  92:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 571               		.loc 1 92 0 discriminator 2
 572 021c 90E0      		ldi r25,hi8(matrix_debouncing+10)
 573 021e E030      		cpi r30,lo8(matrix_debouncing+10)
 574 0220 F907      		cpc r31,r25
 575 0222 01F4      		brne .L42
 576               	.L39:
 577               	.LBE50:
  98:matrix.c      ****     uint8_t layer = biton32(layer_state);
 578               		.loc 1 98 0
 579 0224 6091 0000 		lds r22,layer_state
 580 0228 7091 0000 		lds r23,layer_state+1
 581 022c 8091 0000 		lds r24,layer_state+2
 582 0230 9091 0000 		lds r25,layer_state+3
 583 0234 0E94 0000 		call biton32
 584               	.LVL14:
  99:matrix.c      ****     switch (layer) {
 585               		.loc 1 99 0
 586 0238 8823      		tst r24
 587 023a 01F0      		breq .L44
 588 023c 8330      		cpi r24,lo8(3)
 589 023e 00F4      		brsh .L43
 102:matrix.c      ****             DDRC |= (1<<7);
 590               		.loc 1 102 0
 591 0240 3F9A      		sbi 0x7,7
 103:matrix.c      ****             PORTC |= (1<<7);
 592               		.loc 1 103 0
 593 0242 479A      		sbi 0x8,7
 104:matrix.c      ****             break;
 594               		.loc 1 104 0
 595 0244 00C0      		rjmp .L43
 596               	.L44:
 106:matrix.c      ****             DDRC &= ~(1<<7);
 597               		.loc 1 106 0
 598 0246 3F98      		cbi 0x7,7
 107:matrix.c      ****             PORTC &= ~(1<<7);
 599               		.loc 1 107 0
 600 0248 4798      		cbi 0x8,7
 601               	.L43:
 112:matrix.c      **** }
 602               		.loc 1 112 0
 603 024a 81E0      		ldi r24,lo8(1)
 604               	.LVL15:
 605               	/* epilogue start */
 606 024c DF91      		pop r29
 607 024e CF91      		pop r28
 608 0250 1F91      		pop r17
 609               	.LVL16:
 610 0252 0F91      		pop r16
 611 0254 FF90      		pop r15
 612 0256 EF90      		pop r14
 613 0258 0895      		ret
 614               		.cfi_endproc
 615               	.LFE13:
 617               		.section	.text.matrix_is_modified,"ax",@progbits
 618               	.global	matrix_is_modified
 620               	matrix_is_modified:
 621               	.LFB14:
 115:matrix.c      **** {
 622               		.loc 1 115 0
 623               		.cfi_startproc
 624               	/* prologue: function */
 625               	/* frame size = 0 */
 626               	/* stack size = 0 */
 627               	.L__stack_usage = 0
 116:matrix.c      ****     if (debouncing) return false;
 628               		.loc 1 116 0
 629 0000 81E0      		ldi r24,lo8(1)
 630 0002 9091 0000 		lds r25,debouncing
 631 0006 9111      		cpse r25,__zero_reg__
 632 0008 80E0      		ldi r24,0
 633               	.L72:
 118:matrix.c      **** }
 634               		.loc 1 118 0
 635 000a 0895      		ret
 636               		.cfi_endproc
 637               	.LFE14:
 639               		.section	.text.matrix_is_on,"ax",@progbits
 640               	.global	matrix_is_on
 642               	matrix_is_on:
 643               	.LFB15:
 122:matrix.c      **** {
 644               		.loc 1 122 0
 645               		.cfi_startproc
 646               	.LVL17:
 647               	/* prologue: function */
 648               	/* frame size = 0 */
 649               	/* stack size = 0 */
 650               	.L__stack_usage = 0
 123:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 651               		.loc 1 123 0
 652 0000 E82F      		mov r30,r24
 653 0002 F0E0      		ldi r31,0
 654 0004 EE0F      		lsl r30
 655 0006 FF1F      		rol r31
 656 0008 E050      		subi r30,lo8(-(matrix))
 657 000a F040      		sbci r31,hi8(-(matrix))
 658 000c 21E0      		ldi r18,lo8(1)
 659 000e 30E0      		ldi r19,0
 660 0010 00C0      		rjmp 2f
 661               		1:
 662 0012 220F      		lsl r18
 663 0014 331F      		rol r19
 664               		2:
 665 0016 6A95      		dec r22
 666 0018 02F4      		brpl 1b
 667 001a 8081      		ld r24,Z
 668 001c 9181      		ldd r25,Z+1
 669               	.LVL18:
 670 001e 2823      		and r18,r24
 671 0020 3923      		and r19,r25
 672 0022 81E0      		ldi r24,lo8(1)
 673 0024 232B      		or r18,r19
 674 0026 01F4      		brne .L77
 675 0028 80E0      		ldi r24,0
 676               	.L77:
 124:matrix.c      **** }
 677               		.loc 1 124 0
 678 002a 0895      		ret
 679               		.cfi_endproc
 680               	.LFE15:
 682               		.section	.text.matrix_get_row,"ax",@progbits
 683               	.global	matrix_get_row
 685               	matrix_get_row:
 686               	.LFB16:
 128:matrix.c      **** {
 687               		.loc 1 128 0
 688               		.cfi_startproc
 689               	.LVL19:
 690               	/* prologue: function */
 691               	/* frame size = 0 */
 692               	/* stack size = 0 */
 693               	.L__stack_usage = 0
 129:matrix.c      ****     return matrix[row];
 694               		.loc 1 129 0
 695 0000 E82F      		mov r30,r24
 696 0002 F0E0      		ldi r31,0
 697 0004 EE0F      		lsl r30
 698 0006 FF1F      		rol r31
 699               	.LVL20:
 700 0008 E050      		subi r30,lo8(-(matrix))
 701 000a F040      		sbci r31,hi8(-(matrix))
 130:matrix.c      **** }
 702               		.loc 1 130 0
 703 000c 8081      		ld r24,Z
 704 000e 9181      		ldd r25,Z+1
 705 0010 0895      		ret
 706               		.cfi_endproc
 707               	.LFE16:
 709               		.section	.text.matrix_print,"ax",@progbits
 710               	.global	matrix_print
 712               	matrix_print:
 713               	.LFB17:
 133:matrix.c      **** {
 714               		.loc 1 133 0
 715               		.cfi_startproc
 716 0000 CF92      		push r12
 717               	.LCFI11:
 718               		.cfi_def_cfa_offset 3
 719               		.cfi_offset 12, -2
 720 0002 DF92      		push r13
 721               	.LCFI12:
 722               		.cfi_def_cfa_offset 4
 723               		.cfi_offset 13, -3
 724 0004 EF92      		push r14
 725               	.LCFI13:
 726               		.cfi_def_cfa_offset 5
 727               		.cfi_offset 14, -4
 728 0006 FF92      		push r15
 729               	.LCFI14:
 730               		.cfi_def_cfa_offset 6
 731               		.cfi_offset 15, -5
 732 0008 0F93      		push r16
 733               	.LCFI15:
 734               		.cfi_def_cfa_offset 7
 735               		.cfi_offset 16, -6
 736 000a 1F93      		push r17
 737               	.LCFI16:
 738               		.cfi_def_cfa_offset 8
 739               		.cfi_offset 17, -7
 740 000c CF93      		push r28
 741               	.LCFI17:
 742               		.cfi_def_cfa_offset 9
 743               		.cfi_offset 28, -8
 744 000e DF93      		push r29
 745               	.LCFI18:
 746               		.cfi_def_cfa_offset 10
 747               		.cfi_offset 29, -9
 748               	/* prologue: function */
 749               	/* frame size = 0 */
 750               	/* stack size = 8 */
 751               	.L__stack_usage = 8
 134:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 752               		.loc 1 134 0
 753 0010 80E0      		ldi r24,lo8(__c.2356)
 754 0012 90E0      		ldi r25,hi8(__c.2356)
 755 0014 0E94 0000 		call xputs
 756 0018 90E0      		ldi r25,lo8(matrix)
 757 001a E92E      		mov r14,r25
 758 001c 90E0      		ldi r25,hi8(matrix)
 759 001e F92E      		mov r15,r25
 760 0020 C0E0      		ldi r28,0
 761 0022 D0E0      		ldi r29,0
 762               	.LBB51:
 136:matrix.c      ****         phex(row); print(": ");
 763               		.loc 1 136 0
 764 0024 20E0      		ldi r18,lo8(__c.2359)
 765 0026 C22E      		mov r12,r18
 766 0028 20E0      		ldi r18,hi8(__c.2359)
 767 002a D22E      		mov r13,r18
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 768               		.loc 1 137 0
 769 002c 00E0      		ldi r16,lo8(__c.2363)
 770 002e 10E0      		ldi r17,hi8(__c.2363)
 771               	.L81:
 136:matrix.c      ****         phex(row); print(": ");
 772               		.loc 1 136 0 discriminator 2
 773 0030 DF93      		push r29
 774               	.LCFI19:
 775               		.cfi_def_cfa_offset 11
 776 0032 CF93      		push r28
 777               	.LCFI20:
 778               		.cfi_def_cfa_offset 12
 779 0034 DF92      		push r13
 780               	.LCFI21:
 781               		.cfi_def_cfa_offset 13
 782 0036 CF92      		push r12
 783               	.LCFI22:
 784               		.cfi_def_cfa_offset 14
 785 0038 0E94 0000 		call __xprintf
 786 003c 80E0      		ldi r24,lo8(__c.2361)
 787 003e 90E0      		ldi r25,hi8(__c.2361)
 788 0040 0E94 0000 		call xputs
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 789               		.loc 1 137 0 discriminator 2
 790 0044 F701      		movw r30,r14
 791 0046 8191      		ld r24,Z+
 792 0048 9191      		ld r25,Z+
 793 004a 7F01      		movw r14,r30
 794 004c 0E94 0000 		call bitrev16
 795 0050 9F93      		push r25
 796               	.LCFI23:
 797               		.cfi_def_cfa_offset 15
 798 0052 8F93      		push r24
 799               	.LCFI24:
 800               		.cfi_def_cfa_offset 16
 801 0054 1F93      		push r17
 802               	.LCFI25:
 803               		.cfi_def_cfa_offset 17
 804 0056 0F93      		push r16
 805               	.LCFI26:
 806               		.cfi_def_cfa_offset 18
 807 0058 0E94 0000 		call __xprintf
 138:matrix.c      ****         print("\n");
 808               		.loc 1 138 0 discriminator 2
 809 005c 80E0      		ldi r24,lo8(__c.2365)
 810 005e 90E0      		ldi r25,hi8(__c.2365)
 811 0060 0E94 0000 		call xputs
 812 0064 2196      		adiw r28,1
 135:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 813               		.loc 1 135 0 discriminator 2
 814 0066 8DB7      		in r24,__SP_L__
 815 0068 9EB7      		in r25,__SP_H__
 816 006a 0896      		adiw r24,8
 817 006c 0FB6      		in __tmp_reg__,__SREG__
 818 006e F894      		cli
 819 0070 9EBF      		out __SP_H__,r25
 820 0072 0FBE      		out __SREG__,__tmp_reg__
 821 0074 8DBF      		out __SP_L__,r24
 822               	.LCFI27:
 823               		.cfi_def_cfa_offset 10
 824 0076 C530      		cpi r28,5
 825 0078 D105      		cpc r29,__zero_reg__
 826 007a 01F4      		brne .L81
 827               	/* epilogue start */
 828               	.LBE51:
 140:matrix.c      **** }
 829               		.loc 1 140 0
 830 007c DF91      		pop r29
 831 007e CF91      		pop r28
 832 0080 1F91      		pop r17
 833 0082 0F91      		pop r16
 834 0084 FF90      		pop r15
 835 0086 EF90      		pop r14
 836 0088 DF90      		pop r13
 837 008a CF90      		pop r12
 838 008c 0895      		ret
 839               		.cfi_endproc
 840               	.LFE17:
 842               		.section	.text.matrix_key_count,"ax",@progbits
 843               	.global	matrix_key_count
 845               	matrix_key_count:
 846               	.LFB18:
 143:matrix.c      **** {
 847               		.loc 1 143 0
 848               		.cfi_startproc
 849 0000 1F93      		push r17
 850               	.LCFI28:
 851               		.cfi_def_cfa_offset 3
 852               		.cfi_offset 17, -2
 853 0002 CF93      		push r28
 854               	.LCFI29:
 855               		.cfi_def_cfa_offset 4
 856               		.cfi_offset 28, -3
 857 0004 DF93      		push r29
 858               	.LCFI30:
 859               		.cfi_def_cfa_offset 5
 860               		.cfi_offset 29, -4
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 3 */
 864               	.L__stack_usage = 3
 865               	.LVL21:
 866 0006 C0E0      		ldi r28,lo8(matrix)
 867 0008 D0E0      		ldi r29,hi8(matrix)
 144:matrix.c      ****     uint8_t count = 0;
 868               		.loc 1 144 0
 869 000a 10E0      		ldi r17,0
 870               	.LVL22:
 871               	.L84:
 872               	.LBB52:
 146:matrix.c      ****         count += bitpop16(matrix[i]);
 873               		.loc 1 146 0 discriminator 2
 874 000c 8991      		ld r24,Y+
 875 000e 9991      		ld r25,Y+
 876 0010 0E94 0000 		call bitpop16
 877               	.LVL23:
 878 0014 180F      		add r17,r24
 879               	.LVL24:
 145:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 880               		.loc 1 145 0 discriminator 2
 881 0016 80E0      		ldi r24,hi8(matrix+10)
 882 0018 C030      		cpi r28,lo8(matrix+10)
 883 001a D807      		cpc r29,r24
 884 001c 01F4      		brne .L84
 885               	.LBE52:
 149:matrix.c      **** }
 886               		.loc 1 149 0
 887 001e 812F      		mov r24,r17
 888               	/* epilogue start */
 889 0020 DF91      		pop r29
 890 0022 CF91      		pop r28
 891 0024 1F91      		pop r17
 892               	.LVL25:
 893 0026 0895      		ret
 894               		.cfi_endproc
 895               	.LFE18:
 897               		.section	.progmem.data.__c.2365,"a",@progbits
 900               	__c.2365:
 901 0000 0A00      		.string	"\n"
 902               		.section	.progmem.data.__c.2363,"a",@progbits
 905               	__c.2363:
 906 0000 2530 3136 		.string	"%016b"
 906      6200 
 907               		.section	.progmem.data.__c.2361,"a",@progbits
 910               	__c.2361:
 911 0000 3A20 00   		.string	": "
 912               		.section	.progmem.data.__c.2359,"a",@progbits
 915               	__c.2359:
 916 0000 2530 3258 		.string	"%02X"
 916      00
 917               		.section	.progmem.data.__c.2356,"a",@progbits
 920               	__c.2356:
 921 0000 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 921      2030 3132 
 921      3334 3536 
 921      3738 3941 
 921      4243 4445 
 922               		.section	.progmem.data.__c.2329,"a",@progbits
 925               	__c.2329:
 926 0000 0A00      		.string	"\n"
 927               		.section	.progmem.data.__c.2327,"a",@progbits
 930               	__c.2327:
 931 0000 2530 3258 		.string	"%02X"
 931      00
 932               		.section	.progmem.data.__c.2325,"a",@progbits
 935               	__c.2325:
 936 0000 626F 756E 		.string	"bounce!: "
 936      6365 213A 
 936      2000 
 937               		.section	.bss.matrix_debouncing,"aw",@nobits
 940               	matrix_debouncing:
 941 0000 0000 0000 		.zero	10
 941      0000 0000 
 941      0000 
 942               		.section	.bss.matrix,"aw",@nobits
 945               	matrix:
 946 0000 0000 0000 		.zero	10
 946      0000 0000 
 946      0000 
 947               		.section	.data.debouncing,"aw",@progbits
 950               	debouncing:
 951 0000 05        		.byte	5
 952               		.text
 953               	.Letext0:
 954               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 955               		.file 4 "../../tmk_core/common/debug.h"
 956               		.file 5 "../../tmk_core/common/matrix.h"
 957               		.file 6 "../../tmk_core/common/action_layer.h"
 958               		.file 7 "../../tmk_core/common/avr/xprintf.h"
 959               		.file 8 "../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:00000000 matrix.c
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:2      *ABS*:0000003e __SP_H__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:3      *ABS*:0000003d __SP_L__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:4      *ABS*:0000003f __SREG__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:6      *ABS*:00000001 __zero_reg__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:12     .text.unselect_rows:00000000 unselect_rows
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:40     .text.matrix_rows:00000000 matrix_rows
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:57     .text.matrix_cols:00000000 matrix_cols
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:74     .text.matrix_init:00000000 matrix_init
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:945    .bss.matrix:00000000 matrix
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:940    .bss.matrix_debouncing:00000000 matrix_debouncing
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:146    .text.matrix_scan:00000000 matrix_scan
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:930    .progmem.data.__c.2327:00000000 __c.2327
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:950    .data.debouncing:00000000 debouncing
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:935    .progmem.data.__c.2325:00000000 __c.2325
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:925    .progmem.data.__c.2329:00000000 __c.2329
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:620    .text.matrix_is_modified:00000000 matrix_is_modified
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:642    .text.matrix_is_on:00000000 matrix_is_on
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:685    .text.matrix_get_row:00000000 matrix_get_row
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:712    .text.matrix_print:00000000 matrix_print
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:920    .progmem.data.__c.2356:00000000 __c.2356
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:915    .progmem.data.__c.2359:00000000 __c.2359
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:905    .progmem.data.__c.2363:00000000 __c.2363
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:910    .progmem.data.__c.2361:00000000 __c.2361
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:900    .progmem.data.__c.2365:00000000 __c.2365
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccelydPr.s:845    .text.matrix_key_count:00000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
layer_state
biton32
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
