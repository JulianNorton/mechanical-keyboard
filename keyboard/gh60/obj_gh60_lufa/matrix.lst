   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB23:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "action_layer.h"
  26:matrix.c      **** #include "print.h"
  27:matrix.c      **** #include "debug.h"
  28:matrix.c      **** #include "util.h"
  29:matrix.c      **** #include "matrix.h"
  30:matrix.c      **** 
  31:matrix.c      **** 
  32:matrix.c      **** #ifndef DEBOUNCE
  33:matrix.c      **** #   define DEBOUNCE	10
  34:matrix.c      **** #endif
  35:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  36:matrix.c      **** 
  37:matrix.c      **** /* matrix state(1:on, 0:off) */
  38:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  39:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  40:matrix.c      **** 
  41:matrix.c      **** static matrix_row_t read_cols(void);
  42:matrix.c      **** static void init_cols(void);
  43:matrix.c      **** static void unselect_rows(void);
  44:matrix.c      **** static void select_row(uint8_t row);
  45:matrix.c      **** 
  46:matrix.c      **** 
  47:matrix.c      **** inline
  48:matrix.c      **** uint8_t matrix_rows(void)
  49:matrix.c      **** {
  50:matrix.c      ****     return MATRIX_ROWS;
  51:matrix.c      **** }
  52:matrix.c      **** 
  53:matrix.c      **** inline
  54:matrix.c      **** uint8_t matrix_cols(void)
  55:matrix.c      **** {
  56:matrix.c      ****     return MATRIX_COLS;
  57:matrix.c      **** }
  58:matrix.c      **** 
  59:matrix.c      **** void matrix_init(void)
  60:matrix.c      **** {
  61:matrix.c      ****     // initialize row and col
  62:matrix.c      ****     unselect_rows();
  63:matrix.c      ****     init_cols();
  64:matrix.c      **** 
  65:matrix.c      ****     // initialize matrix state: all keys off
  66:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  67:matrix.c      ****         matrix[i] = 0;
  68:matrix.c      ****         matrix_debouncing[i] = 0;
  69:matrix.c      ****     }
  70:matrix.c      **** }
  71:matrix.c      **** 
  72:matrix.c      **** uint8_t matrix_scan(void)
  73:matrix.c      **** {
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  75:matrix.c      ****         select_row(i);
  76:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  77:matrix.c      ****         matrix_row_t cols = read_cols();
  78:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  79:matrix.c      ****             matrix_debouncing[i] = cols;
  80:matrix.c      ****             if (debouncing) {
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  82:matrix.c      ****             }
  83:matrix.c      ****             debouncing = DEBOUNCE;
  84:matrix.c      ****         }
  85:matrix.c      ****         unselect_rows();
  86:matrix.c      ****     }
  87:matrix.c      **** 
  88:matrix.c      ****     if (debouncing) {
  89:matrix.c      ****         if (--debouncing) {
  90:matrix.c      ****             _delay_ms(1);
  91:matrix.c      ****         } else {
  92:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  93:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  94:matrix.c      ****             }
  95:matrix.c      ****         }
  96:matrix.c      ****     }
  97:matrix.c      **** 
  98:matrix.c      ****     uint8_t layer = biton32(layer_state);
  99:matrix.c      ****     switch (layer) {
 100:matrix.c      ****         case 1:
 101:matrix.c      ****         case 2:
 102:matrix.c      ****             DDRC |= (1<<7);
 103:matrix.c      ****             PORTC |= (1<<7);
 104:matrix.c      ****             break;
 105:matrix.c      ****         case 0:
 106:matrix.c      ****             DDRC &= ~(1<<7);
 107:matrix.c      ****             PORTC &= ~(1<<7);
 108:matrix.c      ****             break;
 109:matrix.c      ****     }
 110:matrix.c      **** 
 111:matrix.c      ****     return 1;
 112:matrix.c      **** }
 113:matrix.c      **** 
 114:matrix.c      **** bool matrix_is_modified(void)
 115:matrix.c      **** {
 116:matrix.c      ****     if (debouncing) return false;
 117:matrix.c      ****     return true;
 118:matrix.c      **** }
 119:matrix.c      **** 
 120:matrix.c      **** inline
 121:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 122:matrix.c      **** {
 123:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 124:matrix.c      **** }
 125:matrix.c      **** 
 126:matrix.c      **** inline
 127:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 128:matrix.c      **** {
 129:matrix.c      ****     return matrix[row];
 130:matrix.c      **** }
 131:matrix.c      **** 
 132:matrix.c      **** void matrix_print(void)
 133:matrix.c      **** {
 134:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 135:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 136:matrix.c      ****         phex(row); print(": ");
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 138:matrix.c      ****         print("\n");
 139:matrix.c      ****     }
 140:matrix.c      **** }
 141:matrix.c      **** 
 142:matrix.c      **** uint8_t matrix_key_count(void)
 143:matrix.c      **** {
 144:matrix.c      ****     uint8_t count = 0;
 145:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 146:matrix.c      ****         count += bitpop16(matrix[i]);
 147:matrix.c      ****     }
 148:matrix.c      ****     return count;
 149:matrix.c      **** }
 150:matrix.c      **** 
 151:matrix.c      **** /* Column pin configuration
 152:matrix.c      ****  * col: 0  1  2  3  4  5  6  7  8  9  10 11
 153:matrix.c      ****  * pin: F0 F1 F4 F5 F6 F7 B6 B5 B4 D7 D5 D4
 154:matrix.c      ****  */
 155:matrix.c      **** 
 156:matrix.c      **** static void init_cols(void)
 157:matrix.c      **** {
 158:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 159:matrix.c      ****     // 'F' port columns enabled
 160:matrix.c      ****     DDRF  &= ~(1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 161:matrix.c      ****     PORTF |=  (1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 162:matrix.c      ****     // 'B' port columns enabled
 163:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 164:matrix.c      ****     PORTB |=  (1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 165:matrix.c      ****     // 'D' ports columns enabled
 166:matrix.c      ****     DDRD  &= ~(1<<7);
 167:matrix.c      ****     PORTD |=  (1<<7);
 168:matrix.c      **** }
 169:matrix.c      **** 
 170:matrix.c      **** static matrix_row_t read_cols(void)
 171:matrix.c      **** {
 172:matrix.c      ****     return 
 173:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<0)) |
 174:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<1)) |
 175:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<2)) |
 176:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<3)) |
 177:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<4)) |
 178:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<< 5)) |
 179:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<< 6)) |
 180:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<< 7)) |
 181:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<< 8)) |
 182:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<< 9)) |
 183:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<< 10)) |
 184:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<< 11)) |
 185:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<< 12)) |
 186:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<< 13)) |
 187:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<< 14)) ;
 188:matrix.c      **** }
 189:matrix.c      **** 
 190:matrix.c      **** /* Row pin configuration
 191:matrix.c      ****  * row: 0  1  2  3
 192:matrix.c      ****  * pin: B0 B1 B2 B3
 193:matrix.c      ****  */
 194:matrix.c      **** static void unselect_rows(void)
 195:matrix.c      **** {
  15               		.loc 1 195 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 196:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 197:matrix.c      ****     DDRB  &= ~0b01110000;
  21               		.loc 1 197 0
  22 0000 84B1      		in r24,0x4
  23 0002 8F78      		andi r24,lo8(-113)
  24 0004 84B9      		out 0x4,r24
 198:matrix.c      ****     PORTB &= ~0b01110000;
  25               		.loc 1 198 0
  26 0006 85B1      		in r24,0x5
  27 0008 8F78      		andi r24,lo8(-113)
  28 000a 85B9      		out 0x5,r24
 199:matrix.c      ****     DDRD  &= ~0b10000000;
  29               		.loc 1 199 0
  30 000c 5798      		cbi 0xa,7
 200:matrix.c      ****     PORTD &= ~0b10000000;
  31               		.loc 1 200 0
  32 000e 5F98      		cbi 0xb,7
  33 0010 0895      		ret
  34               		.cfi_endproc
  35               	.LFE23:
  37               		.section	.text.matrix_power_up,"ax",@progbits
  38               		.weak	matrix_power_up
  40               	matrix_power_up:
  41               	.LFB9:
  42               		.file 2 "../../common/keyboard.h"
   1:../../common/keyboard.h **** /*
   2:../../common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:../../common/keyboard.h **** 
   4:../../common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:../../common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:../../common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:../../common/keyboard.h **** (at your option) any later version.
   8:../../common/keyboard.h **** 
   9:../../common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:../../common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:../../common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:../../common/keyboard.h **** GNU General Public License for more details.
  13:../../common/keyboard.h **** 
  14:../../common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:../../common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:../../common/keyboard.h **** */
  17:../../common/keyboard.h **** 
  18:../../common/keyboard.h **** #ifndef KEYBOARD_H
  19:../../common/keyboard.h **** #define KEYBOARD_H
  20:../../common/keyboard.h **** 
  21:../../common/keyboard.h **** #include <stdbool.h>
  22:../../common/keyboard.h **** #include <stdint.h>
  23:../../common/keyboard.h **** 
  24:../../common/keyboard.h **** 
  25:../../common/keyboard.h **** #ifdef __cplusplus
  26:../../common/keyboard.h **** extern "C" {
  27:../../common/keyboard.h **** #endif
  28:../../common/keyboard.h **** 
  29:../../common/keyboard.h **** /* key matrix position */
  30:../../common/keyboard.h **** typedef struct {
  31:../../common/keyboard.h ****     uint8_t col;
  32:../../common/keyboard.h ****     uint8_t row;
  33:../../common/keyboard.h **** } keypos_t;
  34:../../common/keyboard.h **** 
  35:../../common/keyboard.h **** /* key event */
  36:../../common/keyboard.h **** typedef struct {
  37:../../common/keyboard.h ****     keypos_t key;
  38:../../common/keyboard.h ****     bool     pressed;
  39:../../common/keyboard.h ****     uint16_t time;
  40:../../common/keyboard.h **** } keyevent_t;
  41:../../common/keyboard.h **** 
  42:../../common/keyboard.h **** /* equivalent test of keypos_t */
  43:../../common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:../../common/keyboard.h **** 
  45:../../common/keyboard.h **** /* Rules for No Event:
  46:../../common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:../../common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:../../common/keyboard.h ****  */
  49:../../common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  50:../../common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
  51:../../common/keyboard.h **** static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
  52:../../common/keyboard.h **** 
  53:../../common/keyboard.h **** /* Tick event */
  54:../../common/keyboard.h **** #define TICK                    (keyevent_t){           \
  55:../../common/keyboard.h ****     .key = (keypos_t){ .row = 255, .col = 255 },           \
  56:../../common/keyboard.h ****     .pressed = false,                                   \
  57:../../common/keyboard.h ****     .time = (timer_read() | 1)                          \
  58:../../common/keyboard.h **** }
  59:../../common/keyboard.h **** 
  60:../../common/keyboard.h **** 
  61:../../common/keyboard.h **** void keyboard_init(void);
  62:../../common/keyboard.h **** void keyboard_task(void);
  63:../../common/keyboard.h **** void keyboard_set_leds(uint8_t leds);
  64:../../common/keyboard.h **** 
  65:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_up(void) {}
  43               		.loc 2 65 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49 0000 0895      		ret
  50               		.cfi_endproc
  51               	.LFE9:
  53               		.section	.text.matrix_power_down,"ax",@progbits
  54               		.weak	matrix_power_down
  56               	matrix_power_down:
  57               	.LFB10:
  66:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_down(void) {}
  58               		.loc 2 66 0
  59               		.cfi_startproc
  60               	/* prologue: function */
  61               	/* frame size = 0 */
  62               	/* stack size = 0 */
  63               	.L__stack_usage = 0
  64 0000 0895      		ret
  65               		.cfi_endproc
  66               	.LFE10:
  68               		.section	.text.matrix_rows,"ax",@progbits
  69               	.global	matrix_rows
  71               	matrix_rows:
  72               	.LFB12:
  49:matrix.c      **** {
  73               		.loc 1 49 0
  74               		.cfi_startproc
  75               	/* prologue: function */
  76               	/* frame size = 0 */
  77               	/* stack size = 0 */
  78               	.L__stack_usage = 0
  51:matrix.c      **** }
  79               		.loc 1 51 0
  80 0000 85E0      		ldi r24,lo8(5)
  81 0002 0895      		ret
  82               		.cfi_endproc
  83               	.LFE12:
  85               		.section	.text.matrix_cols,"ax",@progbits
  86               	.global	matrix_cols
  88               	matrix_cols:
  89               	.LFB13:
  55:matrix.c      **** {
  90               		.loc 1 55 0
  91               		.cfi_startproc
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 0 */
  95               	.L__stack_usage = 0
  57:matrix.c      **** }
  96               		.loc 1 57 0
  97 0000 8EE0      		ldi r24,lo8(14)
  98 0002 0895      		ret
  99               		.cfi_endproc
 100               	.LFE13:
 102               		.section	.text.matrix_init,"ax",@progbits
 103               	.global	matrix_init
 105               	matrix_init:
 106               	.LFB14:
  60:matrix.c      **** {
 107               		.loc 1 60 0
 108               		.cfi_startproc
 109               	/* prologue: function */
 110               	/* frame size = 0 */
 111               	/* stack size = 0 */
 112               	.L__stack_usage = 0
  62:matrix.c      ****     unselect_rows();
 113               		.loc 1 62 0
 114 0000 0E94 0000 		call unselect_rows
 115               	.LVL0:
 116               	.LBB23:
 117               	.LBB24:
 160:matrix.c      ****     DDRF  &= ~(1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 118               		.loc 1 160 0
 119 0004 80B3      		in r24,0x10
 120 0006 8C70      		andi r24,lo8(12)
 121 0008 80BB      		out 0x10,r24
 161:matrix.c      ****     PORTF |=  (1<<0 | 1<<1 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 122               		.loc 1 161 0
 123 000a 81B3      		in r24,0x11
 124 000c 836F      		ori r24,lo8(-13)
 125 000e 81BB      		out 0x11,r24
 163:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 126               		.loc 1 163 0
 127 0010 84B1      		in r24,0x4
 128 0012 14B8      		out 0x4,__zero_reg__
 164:matrix.c      ****     PORTB |=  (1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 129               		.loc 1 164 0
 130 0014 85B1      		in r24,0x5
 131 0016 8FEF      		ldi r24,lo8(-1)
 132 0018 85B9      		out 0x5,r24
 166:matrix.c      ****     DDRD  &= ~(1<<7);
 133               		.loc 1 166 0
 134 001a 5798      		cbi 0xa,7
 167:matrix.c      ****     PORTD |=  (1<<7);
 135               		.loc 1 167 0
 136 001c 5F9A      		sbi 0xb,7
 137               	.LVL1:
 138 001e E0E0      		ldi r30,lo8(matrix)
 139 0020 F0E0      		ldi r31,hi8(matrix)
 140 0022 A0E0      		ldi r26,lo8(matrix_debouncing)
 141 0024 B0E0      		ldi r27,hi8(matrix_debouncing)
 142               	.LVL2:
 143               	.L8:
 144               	.LBE24:
 145               	.LBE23:
 146               	.LBB25:
  67:matrix.c      ****         matrix[i] = 0;
 147               		.loc 1 67 0 discriminator 2
 148 0026 1192      		st Z+,__zero_reg__
 149 0028 1192      		st Z+,__zero_reg__
  68:matrix.c      ****         matrix_debouncing[i] = 0;
 150               		.loc 1 68 0 discriminator 2
 151 002a 1D92      		st X+,__zero_reg__
 152 002c 1D92      		st X+,__zero_reg__
  66:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 153               		.loc 1 66 0 discriminator 2
 154 002e 80E0      		ldi r24,hi8(matrix+10)
 155 0030 E030      		cpi r30,lo8(matrix+10)
 156 0032 F807      		cpc r31,r24
 157 0034 01F4      		brne .L8
 158               	/* epilogue start */
 159               	.LBE25:
  70:matrix.c      **** }
 160               		.loc 1 70 0
 161 0036 0895      		ret
 162               		.cfi_endproc
 163               	.LFE14:
 165               		.section	.text.matrix_scan,"ax",@progbits
 166               	.global	matrix_scan
 168               	matrix_scan:
 169               	.LFB15:
  73:matrix.c      **** {
 170               		.loc 1 73 0
 171               		.cfi_startproc
 172 0000 EF92      		push r14
 173               	.LCFI0:
 174               		.cfi_def_cfa_offset 3
 175               		.cfi_offset 14, -2
 176 0002 FF92      		push r15
 177               	.LCFI1:
 178               		.cfi_def_cfa_offset 4
 179               		.cfi_offset 15, -3
 180 0004 1F93      		push r17
 181               	.LCFI2:
 182               		.cfi_def_cfa_offset 5
 183               		.cfi_offset 17, -4
 184 0006 CF93      		push r28
 185               	.LCFI3:
 186               		.cfi_def_cfa_offset 6
 187               		.cfi_offset 28, -5
 188 0008 DF93      		push r29
 189               	.LCFI4:
 190               		.cfi_def_cfa_offset 7
 191               		.cfi_offset 29, -6
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 5 */
 195               	.L__stack_usage = 5
 196               	.LVL3:
  73:matrix.c      **** {
 197               		.loc 1 73 0
 198 000a C0E0      		ldi r28,lo8(matrix_debouncing)
 199 000c D0E0      		ldi r29,hi8(matrix_debouncing)
 200               	.LBB40:
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 201               		.loc 1 74 0
 202 000e 10E0      		ldi r17,0
 203               	.LBB41:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 204               		.loc 1 81 0
 205 0010 E0E0      		ldi r30,lo8(__c.2329)
 206 0012 EE2E      		mov r14,r30
 207 0014 E0E0      		ldi r30,hi8(__c.2329)
 208 0016 FE2E      		mov r15,r30
 209               	.LVL4:
 210               	.L39:
 211               	.LBB42:
 212               	.LBB43:
 201:matrix.c      **** }
 202:matrix.c      **** 
 203:matrix.c      **** static void select_row(uint8_t row)
 204:matrix.c      **** {
 205:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 206:matrix.c      ****        switch (row) {
 213               		.loc 1 206 0
 214 0018 1230      		cpi r17,lo8(2)
 215 001a 01F0      		breq .L12
 216 001c 00F4      		brsh .L13
 217 001e 1130      		cpi r17,lo8(1)
 218 0020 01F0      		breq .L14
 219 0022 00C0      		rjmp .L11
 220               	.L13:
 221 0024 1330      		cpi r17,lo8(3)
 222 0026 01F0      		breq .L15
 223 0028 1430      		cpi r17,lo8(4)
 224 002a 01F0      		breq .L16
 225               	.L11:
 207:matrix.c      ****            case 0:
 208:matrix.c      ****                DDRD  |= (1<<0);
 226               		.loc 1 208 0
 227 002c 509A      		sbi 0xa,0
 209:matrix.c      ****                PORTD &= ~(1<<0);
 228               		.loc 1 209 0
 229 002e 5898      		cbi 0xb,0
 230 0030 00C0      		rjmp .L17
 231               	.L14:
 210:matrix.c      ****                break;
 211:matrix.c      ****            case 1:
 212:matrix.c      ****                DDRD  |= (1<<1);
 232               		.loc 1 212 0
 233 0032 519A      		sbi 0xa,1
 213:matrix.c      ****                PORTD &= ~(1<<1);
 234               		.loc 1 213 0
 235 0034 5998      		cbi 0xb,1
 236 0036 00C0      		rjmp .L17
 237               	.L12:
 214:matrix.c      ****                break;
 215:matrix.c      ****            case 2:
 216:matrix.c      ****                DDRD  |= (1<<2);
 238               		.loc 1 216 0
 239 0038 529A      		sbi 0xa,2
 217:matrix.c      ****                PORTD &= ~(1<<2);
 240               		.loc 1 217 0
 241 003a 5A98      		cbi 0xb,2
 242 003c 00C0      		rjmp .L17
 243               	.L15:
 218:matrix.c      ****                break;
 219:matrix.c      ****            case 3:
 220:matrix.c      ****                DDRD  |= (1<<3);
 244               		.loc 1 220 0
 245 003e 539A      		sbi 0xa,3
 221:matrix.c      ****                PORTD &= ~(1<<3);
 246               		.loc 1 221 0
 247 0040 5B98      		cbi 0xb,3
 248 0042 00C0      		rjmp .L17
 249               	.L16:
 222:matrix.c      ****                break;
 223:matrix.c      ****            case 4:
 224:matrix.c      ****                DDRC  |= (1<<6);
 250               		.loc 1 224 0
 251 0044 3E9A      		sbi 0x7,6
 225:matrix.c      ****                PORTC &= ~(1<<6);
 252               		.loc 1 225 0
 253 0046 4698      		cbi 0x8,6
 254               	.L17:
 255               	.LVL5:
 256               	.LBE43:
 257               	.LBE42:
 258               	.LBB44:
 259               	.LBB45:
 260               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 261               		.loc 3 245 0
 262 0048 80EA      		ldi r24,lo8(-96)
 263 004a 8A95      		1: dec r24
 264 004c 01F4      		brne 1b
 265               	.LBE45:
 266               	.LBE44:
 267               	.LBB46:
 268               	.LBB47:
 173:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<0)) |
 269               		.loc 1 173 0
 270 004e 23B1      		in r18,0x3
 271 0050 3327      		clr r19
 272 0052 27FD      		sbrc r18,7
 273 0054 3095      		com r19
 274 0056 2095      		com r18
 275 0058 3095      		com r19
 276 005a 832F      		mov r24,r19
 277 005c 881F      		rol r24
 278 005e 8827      		clr r24
 279 0060 881F      		rol r24
 280 0062 90E0      		ldi r25,0
 174:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<1)) |
 281               		.loc 1 174 0
 282 0064 1B9B      		sbis 0x3,3
 283 0066 00C0      		rjmp .L48
 284 0068 60E0      		ldi r22,0
 285 006a 70E0      		ldi r23,0
 286 006c 00C0      		rjmp .L18
 287               	.L48:
 288 006e 62E0      		ldi r22,lo8(2)
 289 0070 70E0      		ldi r23,0
 290               	.L18:
 173:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<0)) |
 291               		.loc 1 173 0
 292 0072 862B      		or r24,r22
 293 0074 972B      		or r25,r23
 175:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<2)) |
 294               		.loc 1 175 0
 295 0076 1A9B      		sbis 0x3,2
 296 0078 00C0      		rjmp .L49
 297 007a 60E0      		ldi r22,0
 298 007c 70E0      		ldi r23,0
 299 007e 00C0      		rjmp .L19
 300               	.L49:
 301 0080 64E0      		ldi r22,lo8(4)
 302 0082 70E0      		ldi r23,0
 303               	.L19:
 174:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<1)) |
 304               		.loc 1 174 0
 305 0084 682B      		or r22,r24
 306 0086 792B      		or r23,r25
 176:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<3)) |
 307               		.loc 1 176 0
 308 0088 199B      		sbis 0x3,1
 309 008a 00C0      		rjmp .L50
 310 008c 40E0      		ldi r20,0
 311 008e 50E0      		ldi r21,0
 312 0090 00C0      		rjmp .L20
 313               	.L50:
 314 0092 48E0      		ldi r20,lo8(8)
 315 0094 50E0      		ldi r21,0
 316               	.L20:
 175:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<2)) |
 317               		.loc 1 175 0
 318 0096 9B01      		movw r18,r22
 319 0098 242B      		or r18,r20
 320 009a 352B      		or r19,r21
 177:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<4)) |
 321               		.loc 1 177 0
 322 009c 189B      		sbis 0x3,0
 323 009e 00C0      		rjmp .L51
 324 00a0 40E0      		ldi r20,0
 325 00a2 50E0      		ldi r21,0
 326 00a4 00C0      		rjmp .L21
 327               	.L51:
 328 00a6 40E1      		ldi r20,lo8(16)
 329 00a8 50E0      		ldi r21,0
 330               	.L21:
 176:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<3)) |
 331               		.loc 1 176 0
 332 00aa 242B      		or r18,r20
 333 00ac 352B      		or r19,r21
 178:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<< 5)) |
 334               		.loc 1 178 0
 335 00ae 89B1      		in r24,0x9
 336 00b0 9927      		clr r25
 337 00b2 87FD      		sbrc r24,7
 338 00b4 9095      		com r25
 339 00b6 8095      		com r24
 340 00b8 9095      		com r25
 341 00ba 8827      		clr r24
 342 00bc 990F      		lsl r25
 343 00be 881F      		rol r24
 344 00c0 9927      		clr r25
 345 00c2 75E0      		ldi r23,5
 346               		1:
 347 00c4 880F      		lsl r24
 348 00c6 991F      		rol r25
 349 00c8 7A95      		dec r23
 350 00ca 01F4      		brne 1b
 177:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<4)) |
 351               		.loc 1 177 0
 352 00cc 282B      		or r18,r24
 353 00ce 392B      		or r19,r25
 179:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<< 6)) |
 354               		.loc 1 179 0
 355 00d0 1C9B      		sbis 0x3,4
 356 00d2 00C0      		rjmp .L53
 357 00d4 80E0      		ldi r24,0
 358 00d6 90E0      		ldi r25,0
 359 00d8 00C0      		rjmp .L23
 360               	.L53:
 361 00da 80E4      		ldi r24,lo8(64)
 362 00dc 90E0      		ldi r25,0
 363               	.L23:
 178:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<< 5)) |
 364               		.loc 1 178 0
 365 00de 282B      		or r18,r24
 366 00e0 392B      		or r19,r25
 180:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<< 7)) |
 367               		.loc 1 180 0
 368 00e2 1D9B      		sbis 0x3,5
 369 00e4 00C0      		rjmp .L54
 370 00e6 80E0      		ldi r24,0
 371 00e8 90E0      		ldi r25,0
 372 00ea 00C0      		rjmp .L24
 373               	.L54:
 374 00ec 80E8      		ldi r24,lo8(-128)
 375 00ee 90E0      		ldi r25,0
 376               	.L24:
 179:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<< 6)) |
 377               		.loc 1 179 0
 378 00f0 282B      		or r18,r24
 379 00f2 392B      		or r19,r25
 181:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<< 8)) |
 380               		.loc 1 181 0
 381 00f4 1E9B      		sbis 0x3,6
 382 00f6 00C0      		rjmp .L55
 383 00f8 80E0      		ldi r24,0
 384 00fa 90E0      		ldi r25,0
 385 00fc 00C0      		rjmp .L25
 386               	.L55:
 387 00fe 80E0      		ldi r24,0
 388 0100 91E0      		ldi r25,lo8(1)
 389               	.L25:
 180:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<< 7)) |
 390               		.loc 1 180 0
 391 0102 282B      		or r18,r24
 392 0104 392B      		or r19,r25
 182:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<< 9)) |
 393               		.loc 1 182 0
 394 0106 8FB1      		in r24,0xf
 395 0108 9927      		clr r25
 396 010a 87FD      		sbrc r24,7
 397 010c 9095      		com r25
 398 010e 8095      		com r24
 399 0110 9095      		com r25
 400 0112 8827      		clr r24
 401 0114 990F      		lsl r25
 402 0116 881F      		rol r24
 403 0118 9927      		clr r25
 404 011a 982F      		mov r25,r24
 405 011c 8827      		clr r24
 406 011e 990F      		lsl r25
 181:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<< 8)) |
 407               		.loc 1 181 0
 408 0120 282B      		or r18,r24
 409 0122 392B      		or r19,r25
 183:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<< 10)) |
 410               		.loc 1 183 0
 411 0124 7E9B      		sbis 0xf,6
 412 0126 00C0      		rjmp .L57
 413 0128 60E0      		ldi r22,0
 414 012a 70E0      		ldi r23,0
 415 012c 00C0      		rjmp .L27
 416               	.L57:
 417 012e 60E0      		ldi r22,0
 418 0130 74E0      		ldi r23,lo8(4)
 419               	.L27:
 182:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<< 9)) |
 420               		.loc 1 182 0
 421 0132 262B      		or r18,r22
 422 0134 372B      		or r19,r23
 184:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<< 11)) |
 423               		.loc 1 184 0
 424 0136 7D9B      		sbis 0xf,5
 425 0138 00C0      		rjmp .L58
 426 013a 60E0      		ldi r22,0
 427 013c 70E0      		ldi r23,0
 428 013e 00C0      		rjmp .L28
 429               	.L58:
 430 0140 60E0      		ldi r22,0
 431 0142 78E0      		ldi r23,lo8(8)
 432               	.L28:
 183:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<< 10)) |
 433               		.loc 1 183 0
 434 0144 262B      		or r18,r22
 435 0146 372B      		or r19,r23
 185:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<< 12)) |
 436               		.loc 1 185 0
 437 0148 7C9B      		sbis 0xf,4
 438 014a 00C0      		rjmp .L59
 439 014c 40E0      		ldi r20,0
 440 014e 50E0      		ldi r21,0
 441 0150 00C0      		rjmp .L29
 442               	.L59:
 443 0152 40E0      		ldi r20,0
 444 0154 50E1      		ldi r21,lo8(16)
 445               	.L29:
 184:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<< 11)) |
 446               		.loc 1 184 0
 447 0156 242B      		or r18,r20
 448 0158 352B      		or r19,r21
 186:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<< 13)) |
 449               		.loc 1 186 0
 450 015a 799B      		sbis 0xf,1
 451 015c 00C0      		rjmp .L60
 452 015e 80E0      		ldi r24,0
 453 0160 90E0      		ldi r25,0
 454 0162 00C0      		rjmp .L30
 455               	.L60:
 456 0164 80E0      		ldi r24,0
 457 0166 90E2      		ldi r25,lo8(32)
 458               	.L30:
 185:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<< 12)) |
 459               		.loc 1 185 0
 460 0168 282B      		or r18,r24
 461 016a 392B      		or r19,r25
 187:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<< 14)) ;
 462               		.loc 1 187 0
 463 016c 789B      		sbis 0xf,0
 464 016e 00C0      		rjmp .L61
 465 0170 80E0      		ldi r24,0
 466 0172 90E0      		ldi r25,0
 467 0174 00C0      		rjmp .L31
 468               	.L61:
 469 0176 80E0      		ldi r24,0
 470 0178 90E4      		ldi r25,lo8(64)
 471               	.L31:
 186:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<< 13)) |
 472               		.loc 1 186 0
 473 017a 282B      		or r18,r24
 474 017c 392B      		or r19,r25
 475               	.LBE47:
 476               	.LBE46:
  78:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 477               		.loc 1 78 0
 478 017e 8881      		ld r24,Y
 479 0180 9981      		ldd r25,Y+1
 480 0182 8217      		cp r24,r18
 481 0184 9307      		cpc r25,r19
 482 0186 01F0      		breq .L32
  79:matrix.c      ****             matrix_debouncing[i] = cols;
 483               		.loc 1 79 0
 484 0188 3983      		std Y+1,r19
 485 018a 2883      		st Y,r18
  80:matrix.c      ****             if (debouncing) {
 486               		.loc 1 80 0
 487 018c 8091 0000 		lds r24,debouncing
 488 0190 8823      		tst r24
 489 0192 01F0      		breq .L34
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 490               		.loc 1 81 0
 491 0194 8091 0000 		lds r24,debug_config
 492 0198 80FF      		sbrs r24,0
 493 019a 00C0      		rjmp .L35
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 494               		.loc 1 81 0 is_stmt 0 discriminator 1
 495 019c 80E0      		ldi r24,lo8(__c.2327)
 496 019e 90E0      		ldi r25,hi8(__c.2327)
 497 01a0 0E94 0000 		call xputs
 498               	.LVL6:
 499               	.L35:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 500               		.loc 1 81 0 discriminator 2
 501 01a4 8091 0000 		lds r24,debug_config
 502 01a8 80FF      		sbrs r24,0
 503 01aa 00C0      		rjmp .L36
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 504               		.loc 1 81 0 discriminator 1
 505 01ac 8091 0000 		lds r24,debouncing
 506 01b0 1F92      		push __zero_reg__
 507               	.LCFI5:
 508               		.cfi_def_cfa_offset 8
 509 01b2 8F93      		push r24
 510               	.LCFI6:
 511               		.cfi_def_cfa_offset 9
 512 01b4 FF92      		push r15
 513               	.LCFI7:
 514               		.cfi_def_cfa_offset 10
 515 01b6 EF92      		push r14
 516               	.LCFI8:
 517               		.cfi_def_cfa_offset 11
 518 01b8 0E94 0000 		call __xprintf
 519               	.LVL7:
 520 01bc 0F90      		pop __tmp_reg__
 521 01be 0F90      		pop __tmp_reg__
 522 01c0 0F90      		pop __tmp_reg__
 523 01c2 0F90      		pop __tmp_reg__
 524               	.LCFI9:
 525               		.cfi_def_cfa_offset 7
 526               	.L36:
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 527               		.loc 1 81 0 discriminator 2
 528 01c4 8091 0000 		lds r24,debug_config
 529 01c8 80FF      		sbrs r24,0
 530 01ca 00C0      		rjmp .L34
  81:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 531               		.loc 1 81 0 discriminator 1
 532 01cc 80E0      		ldi r24,lo8(__c.2331)
 533 01ce 90E0      		ldi r25,hi8(__c.2331)
 534 01d0 0E94 0000 		call xputs
 535               	.LVL8:
 536               	.L34:
  83:matrix.c      ****             debouncing = DEBOUNCE;
 537               		.loc 1 83 0 is_stmt 1
 538 01d4 85E0      		ldi r24,lo8(5)
 539 01d6 8093 0000 		sts debouncing,r24
 540               	.L32:
  85:matrix.c      ****         unselect_rows();
 541               		.loc 1 85 0
 542 01da 0E94 0000 		call unselect_rows
 543               	.LVL9:
 544               	.LBE41:
  74:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 545               		.loc 1 74 0
 546 01de 1F5F      		subi r17,lo8(-(1))
 547               	.LVL10:
 548 01e0 2296      		adiw r28,2
 549 01e2 1530      		cpi r17,lo8(5)
 550 01e4 01F0      		breq .+2
 551 01e6 00C0      		rjmp .L39
 552               	.LBE40:
  88:matrix.c      ****     if (debouncing) {
 553               		.loc 1 88 0
 554 01e8 8091 0000 		lds r24,debouncing
 555 01ec 8823      		tst r24
 556 01ee 01F0      		breq .L41
  89:matrix.c      ****         if (--debouncing) {
 557               		.loc 1 89 0
 558 01f0 8150      		subi r24,lo8(-(-1))
 559 01f2 8093 0000 		sts debouncing,r24
 560 01f6 8823      		tst r24
 561 01f8 01F0      		breq .L42
 562               	.LVL11:
 563               	.LBB48:
 564               	.LBB49:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 565               		.loc 3 163 0
 566 01fa 8FE9      		ldi r24,lo8(3999)
 567 01fc 9FE0      		ldi r25,hi8(3999)
 568 01fe 0197      		1: sbiw r24,1
 569 0200 01F4      		brne 1b
 570 0202 00C0      		rjmp .
 571 0204 0000      		nop
 572 0206 00C0      		rjmp .L41
 573               	.LVL12:
 574               	.L42:
 575 0208 A0E0      		ldi r26,lo8(matrix)
 576 020a B0E0      		ldi r27,hi8(matrix)
 577               	.LBE49:
 578               	.LBE48:
  89:matrix.c      ****         if (--debouncing) {
 579               		.loc 1 89 0
 580 020c E0E0      		ldi r30,lo8(matrix_debouncing)
 581 020e F0E0      		ldi r31,hi8(matrix_debouncing)
 582               	.L44:
 583               	.LBB50:
  93:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 584               		.loc 1 93 0 discriminator 2
 585 0210 8191      		ld r24,Z+
 586 0212 9191      		ld r25,Z+
 587 0214 8D93      		st X+,r24
 588 0216 9D93      		st X+,r25
 589               	.LVL13:
  92:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 590               		.loc 1 92 0 discriminator 2
 591 0218 90E0      		ldi r25,hi8(matrix_debouncing+10)
 592 021a E030      		cpi r30,lo8(matrix_debouncing+10)
 593 021c F907      		cpc r31,r25
 594 021e 01F4      		brne .L44
 595               	.L41:
 596               	.LBE50:
  98:matrix.c      ****     uint8_t layer = biton32(layer_state);
 597               		.loc 1 98 0
 598 0220 6091 0000 		lds r22,layer_state
 599 0224 7091 0000 		lds r23,layer_state+1
 600 0228 8091 0000 		lds r24,layer_state+2
 601 022c 9091 0000 		lds r25,layer_state+3
 602 0230 0E94 0000 		call biton32
 603               	.LVL14:
  99:matrix.c      ****     switch (layer) {
 604               		.loc 1 99 0
 605 0234 8823      		tst r24
 606 0236 01F0      		breq .L46
 607 0238 8330      		cpi r24,lo8(3)
 608 023a 00F4      		brsh .L45
 102:matrix.c      ****             DDRC |= (1<<7);
 609               		.loc 1 102 0
 610 023c 3F9A      		sbi 0x7,7
 103:matrix.c      ****             PORTC |= (1<<7);
 611               		.loc 1 103 0
 612 023e 479A      		sbi 0x8,7
 104:matrix.c      ****             break;
 613               		.loc 1 104 0
 614 0240 00C0      		rjmp .L45
 615               	.L46:
 106:matrix.c      ****             DDRC &= ~(1<<7);
 616               		.loc 1 106 0
 617 0242 3F98      		cbi 0x7,7
 107:matrix.c      ****             PORTC &= ~(1<<7);
 618               		.loc 1 107 0
 619 0244 4798      		cbi 0x8,7
 620               	.L45:
 112:matrix.c      **** }
 621               		.loc 1 112 0
 622 0246 81E0      		ldi r24,lo8(1)
 623               	.LVL15:
 624               	/* epilogue start */
 625 0248 DF91      		pop r29
 626 024a CF91      		pop r28
 627 024c 1F91      		pop r17
 628               	.LVL16:
 629 024e FF90      		pop r15
 630 0250 EF90      		pop r14
 631 0252 0895      		ret
 632               		.cfi_endproc
 633               	.LFE15:
 635               		.section	.text.matrix_is_modified,"ax",@progbits
 636               	.global	matrix_is_modified
 638               	matrix_is_modified:
 639               	.LFB16:
 115:matrix.c      **** {
 640               		.loc 1 115 0
 641               		.cfi_startproc
 642               	/* prologue: function */
 643               	/* frame size = 0 */
 644               	/* stack size = 0 */
 645               	.L__stack_usage = 0
 116:matrix.c      ****     if (debouncing) return false;
 646               		.loc 1 116 0
 647 0000 81E0      		ldi r24,lo8(1)
 648 0002 9091 0000 		lds r25,debouncing
 649 0006 9111      		cpse r25,__zero_reg__
 650 0008 80E0      		ldi r24,0
 651               	.L74:
 118:matrix.c      **** }
 652               		.loc 1 118 0
 653 000a 0895      		ret
 654               		.cfi_endproc
 655               	.LFE16:
 657               		.section	.text.matrix_is_on,"ax",@progbits
 658               	.global	matrix_is_on
 660               	matrix_is_on:
 661               	.LFB17:
 122:matrix.c      **** {
 662               		.loc 1 122 0
 663               		.cfi_startproc
 664               	.LVL17:
 665               	/* prologue: function */
 666               	/* frame size = 0 */
 667               	/* stack size = 0 */
 668               	.L__stack_usage = 0
 123:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 669               		.loc 1 123 0
 670 0000 E82F      		mov r30,r24
 671 0002 F0E0      		ldi r31,0
 672 0004 EE0F      		lsl r30
 673 0006 FF1F      		rol r31
 674 0008 E050      		subi r30,lo8(-(matrix))
 675 000a F040      		sbci r31,hi8(-(matrix))
 676 000c 21E0      		ldi r18,lo8(1)
 677 000e 30E0      		ldi r19,0
 678 0010 00C0      		rjmp 2f
 679               		1:
 680 0012 220F      		lsl r18
 681 0014 331F      		rol r19
 682               		2:
 683 0016 6A95      		dec r22
 684 0018 02F4      		brpl 1b
 685 001a 8081      		ld r24,Z
 686 001c 9181      		ldd r25,Z+1
 687               	.LVL18:
 688 001e 2823      		and r18,r24
 689 0020 3923      		and r19,r25
 690 0022 81E0      		ldi r24,lo8(1)
 691 0024 232B      		or r18,r19
 692 0026 01F4      		brne .L79
 693 0028 80E0      		ldi r24,0
 694               	.L79:
 124:matrix.c      **** }
 695               		.loc 1 124 0
 696 002a 0895      		ret
 697               		.cfi_endproc
 698               	.LFE17:
 700               		.section	.text.matrix_get_row,"ax",@progbits
 701               	.global	matrix_get_row
 703               	matrix_get_row:
 704               	.LFB18:
 128:matrix.c      **** {
 705               		.loc 1 128 0
 706               		.cfi_startproc
 707               	.LVL19:
 708               	/* prologue: function */
 709               	/* frame size = 0 */
 710               	/* stack size = 0 */
 711               	.L__stack_usage = 0
 129:matrix.c      ****     return matrix[row];
 712               		.loc 1 129 0
 713 0000 E82F      		mov r30,r24
 714 0002 F0E0      		ldi r31,0
 715 0004 EE0F      		lsl r30
 716 0006 FF1F      		rol r31
 717 0008 E050      		subi r30,lo8(-(matrix))
 718 000a F040      		sbci r31,hi8(-(matrix))
 130:matrix.c      **** }
 719               		.loc 1 130 0
 720 000c 8081      		ld r24,Z
 721 000e 9181      		ldd r25,Z+1
 722               	.LVL20:
 723 0010 0895      		ret
 724               		.cfi_endproc
 725               	.LFE18:
 727               		.section	.text.matrix_print,"ax",@progbits
 728               	.global	matrix_print
 730               	matrix_print:
 731               	.LFB19:
 133:matrix.c      **** {
 732               		.loc 1 133 0
 733               		.cfi_startproc
 734 0000 CF92      		push r12
 735               	.LCFI10:
 736               		.cfi_def_cfa_offset 3
 737               		.cfi_offset 12, -2
 738 0002 DF92      		push r13
 739               	.LCFI11:
 740               		.cfi_def_cfa_offset 4
 741               		.cfi_offset 13, -3
 742 0004 EF92      		push r14
 743               	.LCFI12:
 744               		.cfi_def_cfa_offset 5
 745               		.cfi_offset 14, -4
 746 0006 FF92      		push r15
 747               	.LCFI13:
 748               		.cfi_def_cfa_offset 6
 749               		.cfi_offset 15, -5
 750 0008 0F93      		push r16
 751               	.LCFI14:
 752               		.cfi_def_cfa_offset 7
 753               		.cfi_offset 16, -6
 754 000a 1F93      		push r17
 755               	.LCFI15:
 756               		.cfi_def_cfa_offset 8
 757               		.cfi_offset 17, -7
 758 000c CF93      		push r28
 759               	.LCFI16:
 760               		.cfi_def_cfa_offset 9
 761               		.cfi_offset 28, -8
 762 000e DF93      		push r29
 763               	.LCFI17:
 764               		.cfi_def_cfa_offset 10
 765               		.cfi_offset 29, -9
 766               	/* prologue: function */
 767               	/* frame size = 0 */
 768               	/* stack size = 8 */
 769               	.L__stack_usage = 8
 134:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 770               		.loc 1 134 0
 771 0010 80E0      		ldi r24,lo8(__c.2358)
 772 0012 90E0      		ldi r25,hi8(__c.2358)
 773 0014 0E94 0000 		call xputs
 774 0018 C0E0      		ldi r28,lo8(matrix)
 775 001a EC2E      		mov r14,r28
 776 001c C0E0      		ldi r28,hi8(matrix)
 777 001e FC2E      		mov r15,r28
 778 0020 C0E0      		ldi r28,0
 779 0022 D0E0      		ldi r29,0
 780               	.LBB51:
 136:matrix.c      ****         phex(row); print(": ");
 781               		.loc 1 136 0
 782 0024 10E0      		ldi r17,lo8(__c.2361)
 783 0026 C12E      		mov r12,r17
 784 0028 10E0      		ldi r17,hi8(__c.2361)
 785 002a D12E      		mov r13,r17
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 786               		.loc 1 137 0
 787 002c 00E0      		ldi r16,lo8(__c.2365)
 788 002e 10E0      		ldi r17,hi8(__c.2365)
 789               	.L83:
 136:matrix.c      ****         phex(row); print(": ");
 790               		.loc 1 136 0 discriminator 2
 791 0030 DF93      		push r29
 792               	.LCFI18:
 793               		.cfi_def_cfa_offset 11
 794 0032 CF93      		push r28
 795               	.LCFI19:
 796               		.cfi_def_cfa_offset 12
 797 0034 DF92      		push r13
 798               	.LCFI20:
 799               		.cfi_def_cfa_offset 13
 800 0036 CF92      		push r12
 801               	.LCFI21:
 802               		.cfi_def_cfa_offset 14
 803 0038 0E94 0000 		call __xprintf
 804 003c 80E0      		ldi r24,lo8(__c.2363)
 805 003e 90E0      		ldi r25,hi8(__c.2363)
 806 0040 0E94 0000 		call xputs
 137:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 807               		.loc 1 137 0 discriminator 2
 808 0044 F701      		movw r30,r14
 809 0046 8191      		ld r24,Z+
 810 0048 9191      		ld r25,Z+
 811 004a 7F01      		movw r14,r30
 812 004c 0E94 0000 		call bitrev16
 813 0050 9F93      		push r25
 814               	.LCFI22:
 815               		.cfi_def_cfa_offset 15
 816 0052 8F93      		push r24
 817               	.LCFI23:
 818               		.cfi_def_cfa_offset 16
 819 0054 1F93      		push r17
 820               	.LCFI24:
 821               		.cfi_def_cfa_offset 17
 822 0056 0F93      		push r16
 823               	.LCFI25:
 824               		.cfi_def_cfa_offset 18
 825 0058 0E94 0000 		call __xprintf
 138:matrix.c      ****         print("\n");
 826               		.loc 1 138 0 discriminator 2
 827 005c 80E0      		ldi r24,lo8(__c.2367)
 828 005e 90E0      		ldi r25,hi8(__c.2367)
 829 0060 0E94 0000 		call xputs
 830 0064 2196      		adiw r28,1
 135:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 831               		.loc 1 135 0 discriminator 2
 832 0066 8DB7      		in r24,__SP_L__
 833 0068 9EB7      		in r25,__SP_H__
 834 006a 0896      		adiw r24,8
 835 006c 0FB6      		in __tmp_reg__,__SREG__
 836 006e F894      		cli
 837 0070 9EBF      		out __SP_H__,r25
 838 0072 0FBE      		out __SREG__,__tmp_reg__
 839 0074 8DBF      		out __SP_L__,r24
 840               	.LCFI26:
 841               		.cfi_def_cfa_offset 10
 842 0076 C530      		cpi r28,5
 843 0078 D105      		cpc r29,__zero_reg__
 844 007a 01F4      		brne .L83
 845               	/* epilogue start */
 846               	.LBE51:
 140:matrix.c      **** }
 847               		.loc 1 140 0
 848 007c DF91      		pop r29
 849 007e CF91      		pop r28
 850 0080 1F91      		pop r17
 851 0082 0F91      		pop r16
 852 0084 FF90      		pop r15
 853 0086 EF90      		pop r14
 854 0088 DF90      		pop r13
 855 008a CF90      		pop r12
 856 008c 0895      		ret
 857               		.cfi_endproc
 858               	.LFE19:
 860               		.section	.text.matrix_key_count,"ax",@progbits
 861               	.global	matrix_key_count
 863               	matrix_key_count:
 864               	.LFB20:
 143:matrix.c      **** {
 865               		.loc 1 143 0
 866               		.cfi_startproc
 867 0000 1F93      		push r17
 868               	.LCFI27:
 869               		.cfi_def_cfa_offset 3
 870               		.cfi_offset 17, -2
 871 0002 CF93      		push r28
 872               	.LCFI28:
 873               		.cfi_def_cfa_offset 4
 874               		.cfi_offset 28, -3
 875 0004 DF93      		push r29
 876               	.LCFI29:
 877               		.cfi_def_cfa_offset 5
 878               		.cfi_offset 29, -4
 879               	/* prologue: function */
 880               	/* frame size = 0 */
 881               	/* stack size = 3 */
 882               	.L__stack_usage = 3
 883               	.LVL21:
 884 0006 C0E0      		ldi r28,lo8(matrix)
 885 0008 D0E0      		ldi r29,hi8(matrix)
 144:matrix.c      ****     uint8_t count = 0;
 886               		.loc 1 144 0
 887 000a 10E0      		ldi r17,0
 888               	.LVL22:
 889               	.L86:
 890               	.LBB52:
 146:matrix.c      ****         count += bitpop16(matrix[i]);
 891               		.loc 1 146 0 discriminator 2
 892 000c 8991      		ld r24,Y+
 893 000e 9991      		ld r25,Y+
 894 0010 0E94 0000 		call bitpop16
 895               	.LVL23:
 896 0014 180F      		add r17,r24
 897               	.LVL24:
 145:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 898               		.loc 1 145 0 discriminator 2
 899 0016 80E0      		ldi r24,hi8(matrix+10)
 900 0018 C030      		cpi r28,lo8(matrix+10)
 901 001a D807      		cpc r29,r24
 902 001c 01F4      		brne .L86
 903               	.LBE52:
 149:matrix.c      **** }
 904               		.loc 1 149 0
 905 001e 812F      		mov r24,r17
 906               	/* epilogue start */
 907 0020 DF91      		pop r29
 908 0022 CF91      		pop r28
 909 0024 1F91      		pop r17
 910               	.LVL25:
 911 0026 0895      		ret
 912               		.cfi_endproc
 913               	.LFE20:
 915               		.section	.progmem.data,"a",@progbits
 918               	__c.2367:
 919 0000 0A00      		.string	"\n"
 922               	__c.2365:
 923 0002 2530 3136 		.string	"%016b"
 923      6200 
 926               	__c.2363:
 927 0008 3A20 00   		.string	": "
 930               	__c.2361:
 931 000b 2530 3258 		.string	"%02X"
 931      00
 934               	__c.2358:
 935 0010 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 935      2030 3132 
 935      3334 3536 
 935      3738 3941 
 935      4243 4445 
 938               	__c.2331:
 939 0027 0A00      		.string	"\n"
 942               	__c.2329:
 943 0029 2530 3258 		.string	"%02X"
 943      00
 946               	__c.2327:
 947 002e 626F 756E 		.string	"bounce!: "
 947      6365 213A 
 947      2000 
 948               		.local	matrix_debouncing
 949               		.comm	matrix_debouncing,10,1
 950               		.local	matrix
 951               		.comm	matrix,10,1
 952               		.data
 955               	debouncing:
 956 0000 05        		.byte	5
 957               		.text
 958               	.Letext0:
 959               		.file 4 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 960               		.file 5 "../../common/debug.h"
 961               		.file 6 "../../common/matrix.h"
 962               		.file 7 "../../common/action_layer.h"
 963               		.file 8 "../../common/avr/xprintf.h"
 964               		.file 9 "../../common/util.h"
DEFINED SYMBOLS
                            *ABS*:00000000 matrix.c
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:2      *ABS*:0000003e __SP_H__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:3      *ABS*:0000003d __SP_L__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:4      *ABS*:0000003f __SREG__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:6      *ABS*:00000001 __zero_reg__
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:12     .text.unselect_rows:00000000 unselect_rows
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:40     .text.matrix_power_up:00000000 matrix_power_up
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:56     .text.matrix_power_down:00000000 matrix_power_down
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:71     .text.matrix_rows:00000000 matrix_rows
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:88     .text.matrix_cols:00000000 matrix_cols
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:105    .text.matrix_init:00000000 matrix_init
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:949    .bss:0000000a matrix
                             .bss:00000000 matrix_debouncing
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:168    .text.matrix_scan:00000000 matrix_scan
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:942    .progmem.data:00000029 __c.2329
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:955    .data:00000000 debouncing
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:946    .progmem.data:0000002e __c.2327
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:938    .progmem.data:00000027 __c.2331
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:638    .text.matrix_is_modified:00000000 matrix_is_modified
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:660    .text.matrix_is_on:00000000 matrix_is_on
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:703    .text.matrix_get_row:00000000 matrix_get_row
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:730    .text.matrix_print:00000000 matrix_print
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:934    .progmem.data:00000010 __c.2358
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:930    .progmem.data:0000000b __c.2361
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:922    .progmem.data:00000002 __c.2365
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:926    .progmem.data:00000008 __c.2363
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:918    .progmem.data:00000000 __c.2367
/var/folders/1n/7_pxd1gd79b8r2krz1090vjm0000gn/T//ccBTHUGa.s:863    .text.matrix_key_count:00000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
layer_state
biton32
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
